{"path":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","commits":[{"id":"0d8448be43e6bd7d69aa0227187fca146a1f2262","date":1338393518,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @param terms\n   * @param maxSuggestions\n   * @param ir\n   * @param suggestMode\n   * @return an array of words generated by combining original terms\n   * @throws IOException\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    BytesRef reuse = new BytesRef();\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }\n      \n      int byteLength = terms[i].bytes().length;\n      if (byteLength > maxCombineWordLength) {\n        continue;\n      }\n      \n      reuse.grow(byteLength);\n      reuse.length = byteLength;\n      System.arraycopy(terms[i].bytes().bytes, terms[i].bytes().offset,\n          reuse.bytes, 0, byteLength);\n      \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      }\n      \n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        byteLength += terms[j].bytes().length;\n        if (byteLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n        \n        reuse.grow(byteLength);\n        System.arraycopy(terms[j].bytes().bytes, terms[j].bytes().offset,\n            reuse.bytes, reuse.length, terms[j].bytes().length);\n        reuse.length = byteLength;\n        \n        Term combinedTerm = new Term(terms[0].field(), reuse);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["efb805b23fcd6a1644c8bb2f14edb45b1afd97a0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","date":1348430063,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    BytesRef reuse = new BytesRef();\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }\n      \n      int byteLength = terms[i].bytes().length;\n      if (byteLength > maxCombineWordLength) {\n        continue;\n      }\n      \n      reuse.grow(byteLength);\n      reuse.length = byteLength;\n      System.arraycopy(terms[i].bytes().bytes, terms[i].bytes().offset,\n          reuse.bytes, 0, byteLength);\n      \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      }\n      \n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        byteLength += terms[j].bytes().length;\n        if (byteLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n        \n        reuse.grow(byteLength);\n        System.arraycopy(terms[j].bytes().bytes, terms[j].bytes().offset,\n            reuse.bytes, reuse.length, terms[j].bytes().length);\n        reuse.length = byteLength;\n        \n        Term combinedTerm = new Term(terms[0].field(), reuse);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @param terms\n   * @param maxSuggestions\n   * @param ir\n   * @param suggestMode\n   * @return an array of words generated by combining original terms\n   * @throws IOException\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    BytesRef reuse = new BytesRef();\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }\n      \n      int byteLength = terms[i].bytes().length;\n      if (byteLength > maxCombineWordLength) {\n        continue;\n      }\n      \n      reuse.grow(byteLength);\n      reuse.length = byteLength;\n      System.arraycopy(terms[i].bytes().bytes, terms[i].bytes().offset,\n          reuse.bytes, 0, byteLength);\n      \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      }\n      \n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        byteLength += terms[j].bytes().length;\n        if (byteLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n        \n        reuse.grow(byteLength);\n        System.arraycopy(terms[j].bytes().bytes, terms[j].bytes().offset,\n            reuse.bytes, reuse.length, terms[j].bytes().length);\n        reuse.length = byteLength;\n        \n        Term combinedTerm = new Term(terms[0].field(), reuse);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0","date":1354906497,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }      \n      String leftTermText = terms[i].text();\n      int leftTermLength = leftTermText.codePointCount(0, leftTermText.length());\n      if (leftTermLength > maxCombineWordLength) {\n       continue;\n      } \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      } \n      String combinedTermText = leftTermText;\n      int combinedLength = leftTermLength;\n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        String rightTermText = terms[j].text();\n        int rightTermLength = rightTermText.codePointCount(0, rightTermText.length());\n        combinedTermText += rightTermText;\n        combinedLength +=rightTermLength;\n        if (combinedLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n                \n        Term combinedTerm = new Term(terms[0].field(), combinedTermText);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    BytesRef reuse = new BytesRef();\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }\n      \n      int byteLength = terms[i].bytes().length;\n      if (byteLength > maxCombineWordLength) {\n        continue;\n      }\n      \n      reuse.grow(byteLength);\n      reuse.length = byteLength;\n      System.arraycopy(terms[i].bytes().bytes, terms[i].bytes().offset,\n          reuse.bytes, 0, byteLength);\n      \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      }\n      \n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        byteLength += terms[j].bytes().length;\n        if (byteLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n        \n        reuse.grow(byteLength);\n        System.arraycopy(terms[j].bytes().bytes, terms[j].bytes().offset,\n            reuse.bytes, reuse.length, terms[j].bytes().length);\n        reuse.length = byteLength;\n        \n        Term combinedTerm = new Term(terms[0].field(), reuse);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","bugFix":["0d8448be43e6bd7d69aa0227187fca146a1f2262"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }      \n      String leftTermText = terms[i].text();\n      int leftTermLength = leftTermText.codePointCount(0, leftTermText.length());\n      if (leftTermLength > maxCombineWordLength) {\n       continue;\n      } \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      } \n      String combinedTermText = leftTermText;\n      int combinedLength = leftTermLength;\n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        String rightTermText = terms[j].text();\n        int rightTermLength = rightTermText.codePointCount(0, rightTermText.length());\n        combinedTermText += rightTermText;\n        combinedLength +=rightTermLength;\n        if (combinedLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n                \n        Term combinedTerm = new Term(terms[0].field(), combinedTermText);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    BytesRef reuse = new BytesRef();\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }\n      \n      int byteLength = terms[i].bytes().length;\n      if (byteLength > maxCombineWordLength) {\n        continue;\n      }\n      \n      reuse.grow(byteLength);\n      reuse.length = byteLength;\n      System.arraycopy(terms[i].bytes().bytes, terms[i].bytes().offset,\n          reuse.bytes, 0, byteLength);\n      \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      }\n      \n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        byteLength += terms[j].bytes().length;\n        if (byteLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n        \n        reuse.grow(byteLength);\n        System.arraycopy(terms[j].bytes().bytes, terms[j].bytes().offset,\n            reuse.bytes, reuse.length, terms[j].bytes().length);\n        reuse.length = byteLength;\n        \n        Term combinedTerm = new Term(terms[0].field(), reuse);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/spell/WordBreakSpellChecker#suggestWordCombinations(Term[],int,IndexReader,SuggestMode).mjava","sourceNew":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }      \n      String leftTermText = terms[i].text();\n      int leftTermLength = leftTermText.codePointCount(0, leftTermText.length());\n      if (leftTermLength > maxCombineWordLength) {\n       continue;\n      } \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      } \n      String combinedTermText = leftTermText;\n      int combinedLength = leftTermLength;\n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        String rightTermText = terms[j].text();\n        int rightTermLength = rightTermText.codePointCount(0, rightTermText.length());\n        combinedTermText += rightTermText;\n        combinedLength +=rightTermLength;\n        if (combinedLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n                \n        Term combinedTerm = new Term(terms[0].field(), combinedTermText);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","sourceOld":"  /**\n   * <p>\n   * Generate suggestions by combining one or more of the passed-in terms into\n   * single words. The returned {@link CombineSuggestion} contains both a\n   * {@link SuggestWord} and also an array detailing which passed-in terms were\n   * involved in creating this combination. The scores returned are equal to the\n   * number of word combinations needed, also one less than the length of the\n   * array {@link CombineSuggestion#originalTermIndexes}. Generally, a\n   * suggestion with a lower score is preferred over a higher score.\n   * </p>\n   * <p>\n   * To prevent two adjacent terms from being combined (for instance, if one is\n   * mandatory and the other is prohibited), separate the two terms with\n   * {@link WordBreakSpellChecker#SEPARATOR_TERM}\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_WHEN_NOT_IN_INDEX}, each\n   * suggestion will include at least one term not in the index.\n   * </p>\n   * <p>\n   * When suggestMode equals {@link SuggestMode#SUGGEST_MORE_POPULAR}, each\n   * suggestion will have the same, or better frequency than the most-popular\n   * included term.\n   * </p>\n   * \n   * @return an array of words generated by combining original terms\n   * @throws IOException If there is a low-level I/O error.\n   */\n  public CombineSuggestion[] suggestWordCombinations(Term[] terms,\n      int maxSuggestions, IndexReader ir, SuggestMode suggestMode)\n      throws IOException {\n    if (maxSuggestions < 1) {\n      return new CombineSuggestion[0];\n    }\n    \n    int[] origFreqs = null;\n    if (suggestMode != SuggestMode.SUGGEST_ALWAYS) {\n      origFreqs = new int[terms.length];\n      for (int i = 0; i < terms.length; i++) {\n        origFreqs[i] = ir.docFreq(terms[i]);\n      }\n    }\n    \n    int queueInitialCapacity = maxSuggestions > 10 ? 10 : maxSuggestions;\n    Comparator<CombineSuggestionWrapper> queueComparator = new CombinationsThenFreqComparator();\n    Queue<CombineSuggestionWrapper> suggestions = new PriorityQueue<CombineSuggestionWrapper>(\n        queueInitialCapacity, queueComparator);\n    \n    int thisTimeEvaluations = 0;\n    for (int i = 0; i < terms.length - 1; i++) {\n      if (terms[i].equals(SEPARATOR_TERM)) {\n        continue;\n      }      \n      String leftTermText = terms[i].text();\n      int leftTermLength = leftTermText.codePointCount(0, leftTermText.length());\n      if (leftTermLength > maxCombineWordLength) {\n       continue;\n      } \n      int maxFreq = 0;\n      int minFreq = Integer.MAX_VALUE;\n      if (origFreqs != null) {\n        maxFreq = origFreqs[i];\n        minFreq = origFreqs[i];\n      } \n      String combinedTermText = leftTermText;\n      int combinedLength = leftTermLength;\n      for (int j = i + 1; j < terms.length && j - i <= maxChanges; j++) {\n        if (terms[j].equals(SEPARATOR_TERM)) {\n          break;\n        }\n        String rightTermText = terms[j].text();\n        int rightTermLength = rightTermText.codePointCount(0, rightTermText.length());\n        combinedTermText += rightTermText;\n        combinedLength +=rightTermLength;\n        if (combinedLength > maxCombineWordLength) {\n          break;\n        }\n        \n        if (origFreqs != null) {\n          maxFreq = Math.max(maxFreq, origFreqs[j]);\n          minFreq = Math.min(minFreq, origFreqs[j]);\n        }\n                \n        Term combinedTerm = new Term(terms[0].field(), combinedTermText);\n        int combinedTermFreq = ir.docFreq(combinedTerm);\n        \n        if (suggestMode != SuggestMode.SUGGEST_MORE_POPULAR\n            || combinedTermFreq >= maxFreq) {\n          if (suggestMode != SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX\n              || minFreq == 0) {\n            if (combinedTermFreq >= minSuggestionFrequency) {\n              int[] origIndexes = new int[j - i + 1];\n              origIndexes[0] = i;\n              for (int k = 1; k < origIndexes.length; k++) {\n                origIndexes[k] = i + k;\n              }\n              SuggestWord word = new SuggestWord();\n              word.freq = combinedTermFreq;\n              word.score = origIndexes.length - 1;\n              word.string = combinedTerm.text();\n              CombineSuggestionWrapper suggestion = new CombineSuggestionWrapper(\n                  new CombineSuggestion(word, origIndexes),\n                  (origIndexes.length - 1));\n              suggestions.offer(suggestion);\n              if (suggestions.size() > maxSuggestions) {\n                suggestions.poll();\n              }\n            }\n          }\n        }\n        thisTimeEvaluations++;\n        if (thisTimeEvaluations == maxEvaluations) {\n          break;\n        }\n      }\n    }\n    CombineSuggestion[] combineSuggestions = new CombineSuggestion[suggestions\n        .size()];\n    for (int i = suggestions.size() - 1; i >= 0; i--) {\n      combineSuggestions[i] = suggestions.remove().combineSuggestion;\n    }\n    return combineSuggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["0d8448be43e6bd7d69aa0227187fca146a1f2262"],"0d8448be43e6bd7d69aa0227187fca146a1f2262":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["efb805b23fcd6a1644c8bb2f14edb45b1afd97a0"],"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"407687e67faf6e1f02a211ca078d8e3eed631027":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069","efb805b23fcd6a1644c8bb2f14edb45b1afd97a0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"]},"commit2Childs":{"c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069":["efb805b23fcd6a1644c8bb2f14edb45b1afd97a0","407687e67faf6e1f02a211ca078d8e3eed631027"],"0d8448be43e6bd7d69aa0227187fca146a1f2262":["c7bd1fdddb8e84c1857d1a55c32ced51f0ed2069"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"efb805b23fcd6a1644c8bb2f14edb45b1afd97a0":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","407687e67faf6e1f02a211ca078d8e3eed631027"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d8448be43e6bd7d69aa0227187fca146a1f2262"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}