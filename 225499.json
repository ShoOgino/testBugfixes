{"path":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","commits":[{"id":"4c9661df01b81c277277a01afbca7851557a2148","date":1133588656,"type":0,"author":"Wolfgang Hoschek","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","pathOld":"/dev/null","sourceNew":"\tprivate HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n\t\tif (DEBUG) {\n\t\t\tSystem.err.println(\"before gc\");\n\t\t\tfor (int i=0; i < 10; i++) System.gc();\n\t\t\tSystem.err.println(\"after gc\");\n\t\t}\n\t\t\n\t\t// collect entries\n\t\tint len = 0;\n\t\tint size = word2Syns.size();\n\t\tString[][] allSynonyms = new String[size][];\n\t\tString[] words = new String[size];\n\t\tIterator iter = word2Syns.entrySet().iterator();\n\t\tfor (int j=0; j < size; j++) {\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\n\t\t\tallSynonyms[j] = (String[]) entry.getValue(); \n\t\t\twords[j] = (String) entry.getKey();\n\t\t\tlen += words[j].length();\n\t\t}\n\t\t\n\t\t// assemble large string containing all words\n\t\tStringBuffer buf = new StringBuffer(len);\n\t\tfor (int j=0; j < size; j++) buf.append(words[j]);\n\t\tString allWords = new String(buf.toString()); // ensure compact string across JDK versions\n\t\tbuf = null;\n\t\t\n\t\t// intern words at app level via memory-overlaid substrings\n\t\tfor (int p=0, j=0; j < size; j++) {\n\t\t\tString word = words[j];\n\t\t\tinternedWords.put(word, allWords.substring(p, p + word.length()));\n\t\t\tp += word.length();\n\t\t}\n\t\t\n\t\t// replace words with interned words\n\t\tfor (int j=0; j < size; j++) {\n\t\t\tString[] syns = allSynonyms[j];\n\t\t\tfor (int k=syns.length; --k >= 0; ) {\n\t\t\t\tsyns[k] = (String) internedWords.get(syns[k]);\n\t\t\t}\n\t\t\tObject replacement = syns;\n\t\t\tif (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n\t\t\tword2Syns.remove(words[j]);\n\t\t\tword2Syns.put(internedWords.get(words[j]), replacement);\n\t\t}\n\t\t\n\t\tif (DEBUG) {\n\t\t\twords = null;\n\t\t\tallSynonyms = null;\n\t\t\tinternedWords = null;\n\t\t\tallWords = null;\n\t\t\tSystem.err.println(\"before gc\");\n\t\t\tfor (int i=0; i < 10; i++) System.gc();\n\t\t\tSystem.err.println(\"after gc\");\n\t\t}\n\t\treturn word2Syns;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f68e24227d5556d33ee6d586fd9010cd9ff8bec","date":1150091176,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","sourceNew":"  private HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n    if (DEBUG) {\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    \n    // collect entries\n    int len = 0;\n    int size = word2Syns.size();\n    String[][] allSynonyms = new String[size][];\n    String[] words = new String[size];\n    Iterator iter = word2Syns.entrySet().iterator();\n    for (int j=0; j < size; j++) {\n      Map.Entry entry = (Map.Entry) iter.next();\n      allSynonyms[j] = (String[]) entry.getValue(); \n      words[j] = (String) entry.getKey();\n      len += words[j].length();\n    }\n    \n    // assemble large string containing all words\n    StringBuffer buf = new StringBuffer(len);\n    for (int j=0; j < size; j++) buf.append(words[j]);\n    String allWords = new String(buf.toString()); // ensure compact string across JDK versions\n    buf = null;\n    \n    // intern words at app level via memory-overlaid substrings\n    for (int p=0, j=0; j < size; j++) {\n      String word = words[j];\n      internedWords.put(word, allWords.substring(p, p + word.length()));\n      p += word.length();\n    }\n    \n    // replace words with interned words\n    for (int j=0; j < size; j++) {\n      String[] syns = allSynonyms[j];\n      for (int k=syns.length; --k >= 0; ) {\n        syns[k] = (String) internedWords.get(syns[k]);\n      }\n      Object replacement = syns;\n      if (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n      word2Syns.remove(words[j]);\n      word2Syns.put(internedWords.get(words[j]), replacement);\n    }\n    \n    if (DEBUG) {\n      words = null;\n      allSynonyms = null;\n      internedWords = null;\n      allWords = null;\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    return word2Syns;\n  }\n\n","sourceOld":"\tprivate HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n\t\tif (DEBUG) {\n\t\t\tSystem.err.println(\"before gc\");\n\t\t\tfor (int i=0; i < 10; i++) System.gc();\n\t\t\tSystem.err.println(\"after gc\");\n\t\t}\n\t\t\n\t\t// collect entries\n\t\tint len = 0;\n\t\tint size = word2Syns.size();\n\t\tString[][] allSynonyms = new String[size][];\n\t\tString[] words = new String[size];\n\t\tIterator iter = word2Syns.entrySet().iterator();\n\t\tfor (int j=0; j < size; j++) {\n\t\t\tMap.Entry entry = (Map.Entry) iter.next();\n\t\t\tallSynonyms[j] = (String[]) entry.getValue(); \n\t\t\twords[j] = (String) entry.getKey();\n\t\t\tlen += words[j].length();\n\t\t}\n\t\t\n\t\t// assemble large string containing all words\n\t\tStringBuffer buf = new StringBuffer(len);\n\t\tfor (int j=0; j < size; j++) buf.append(words[j]);\n\t\tString allWords = new String(buf.toString()); // ensure compact string across JDK versions\n\t\tbuf = null;\n\t\t\n\t\t// intern words at app level via memory-overlaid substrings\n\t\tfor (int p=0, j=0; j < size; j++) {\n\t\t\tString word = words[j];\n\t\t\tinternedWords.put(word, allWords.substring(p, p + word.length()));\n\t\t\tp += word.length();\n\t\t}\n\t\t\n\t\t// replace words with interned words\n\t\tfor (int j=0; j < size; j++) {\n\t\t\tString[] syns = allSynonyms[j];\n\t\t\tfor (int k=syns.length; --k >= 0; ) {\n\t\t\t\tsyns[k] = (String) internedWords.get(syns[k]);\n\t\t\t}\n\t\t\tObject replacement = syns;\n\t\t\tif (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n\t\t\tword2Syns.remove(words[j]);\n\t\t\tword2Syns.put(internedWords.get(words[j]), replacement);\n\t\t}\n\t\t\n\t\tif (DEBUG) {\n\t\t\twords = null;\n\t\t\tallSynonyms = null;\n\t\t\tinternedWords = null;\n\t\t\tallWords = null;\n\t\t\tSystem.err.println(\"before gc\");\n\t\t\tfor (int i=0; i < 10; i++) System.gc();\n\t\t\tSystem.err.println(\"after gc\");\n\t\t}\n\t\treturn word2Syns;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c","date":1254521470,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","sourceNew":"  private HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n    if (DEBUG) {\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    \n    // collect entries\n    int len = 0;\n    int size = word2Syns.size();\n    String[][] allSynonyms = new String[size][];\n    String[] words = new String[size];\n    Iterator iter = word2Syns.entrySet().iterator();\n    for (int j=0; j < size; j++) {\n      Map.Entry entry = (Map.Entry) iter.next();\n      allSynonyms[j] = (String[]) entry.getValue(); \n      words[j] = (String) entry.getKey();\n      len += words[j].length();\n    }\n    \n    // assemble large string containing all words\n    StringBuilder buf = new StringBuilder(len);\n    for (int j=0; j < size; j++) buf.append(words[j]);\n    String allWords = new String(buf.toString()); // ensure compact string across JDK versions\n    buf = null;\n    \n    // intern words at app level via memory-overlaid substrings\n    for (int p=0, j=0; j < size; j++) {\n      String word = words[j];\n      internedWords.put(word, allWords.substring(p, p + word.length()));\n      p += word.length();\n    }\n    \n    // replace words with interned words\n    for (int j=0; j < size; j++) {\n      String[] syns = allSynonyms[j];\n      for (int k=syns.length; --k >= 0; ) {\n        syns[k] = (String) internedWords.get(syns[k]);\n      }\n      Object replacement = syns;\n      if (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n      word2Syns.remove(words[j]);\n      word2Syns.put(internedWords.get(words[j]), replacement);\n    }\n    \n    if (DEBUG) {\n      words = null;\n      allSynonyms = null;\n      internedWords = null;\n      allWords = null;\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    return word2Syns;\n  }\n\n","sourceOld":"  private HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n    if (DEBUG) {\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    \n    // collect entries\n    int len = 0;\n    int size = word2Syns.size();\n    String[][] allSynonyms = new String[size][];\n    String[] words = new String[size];\n    Iterator iter = word2Syns.entrySet().iterator();\n    for (int j=0; j < size; j++) {\n      Map.Entry entry = (Map.Entry) iter.next();\n      allSynonyms[j] = (String[]) entry.getValue(); \n      words[j] = (String) entry.getKey();\n      len += words[j].length();\n    }\n    \n    // assemble large string containing all words\n    StringBuffer buf = new StringBuffer(len);\n    for (int j=0; j < size; j++) buf.append(words[j]);\n    String allWords = new String(buf.toString()); // ensure compact string across JDK versions\n    buf = null;\n    \n    // intern words at app level via memory-overlaid substrings\n    for (int p=0, j=0; j < size; j++) {\n      String word = words[j];\n      internedWords.put(word, allWords.substring(p, p + word.length()));\n      p += word.length();\n    }\n    \n    // replace words with interned words\n    for (int j=0; j < size; j++) {\n      String[] syns = allSynonyms[j];\n      for (int k=syns.length; --k >= 0; ) {\n        syns[k] = (String) internedWords.get(syns[k]);\n      }\n      Object replacement = syns;\n      if (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n      word2Syns.remove(words[j]);\n      word2Syns.put(internedWords.get(words[j]), replacement);\n    }\n    \n    if (DEBUG) {\n      words = null;\n      allSynonyms = null;\n      internedWords = null;\n      allWords = null;\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    return word2Syns;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d68e5c46e6a5ebdf4dafec4a123344092b915cc0","date":1256752193,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"contrib/wordnet/src/java/org/apache/lucene/wordnet/SynonymMap#optimize(HashMap,HashMap).mjava","pathOld":"contrib/memory/src/java/org/apache/lucene/index/memory/SynonymMap#optimize(HashMap,HashMap).mjava","sourceNew":"  private HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n    if (DEBUG) {\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    \n    // collect entries\n    int len = 0;\n    int size = word2Syns.size();\n    String[][] allSynonyms = new String[size][];\n    String[] words = new String[size];\n    Iterator iter = word2Syns.entrySet().iterator();\n    for (int j=0; j < size; j++) {\n      Map.Entry entry = (Map.Entry) iter.next();\n      allSynonyms[j] = (String[]) entry.getValue(); \n      words[j] = (String) entry.getKey();\n      len += words[j].length();\n    }\n    \n    // assemble large string containing all words\n    StringBuilder buf = new StringBuilder(len);\n    for (int j=0; j < size; j++) buf.append(words[j]);\n    String allWords = new String(buf.toString()); // ensure compact string across JDK versions\n    buf = null;\n    \n    // intern words at app level via memory-overlaid substrings\n    for (int p=0, j=0; j < size; j++) {\n      String word = words[j];\n      internedWords.put(word, allWords.substring(p, p + word.length()));\n      p += word.length();\n    }\n    \n    // replace words with interned words\n    for (int j=0; j < size; j++) {\n      String[] syns = allSynonyms[j];\n      for (int k=syns.length; --k >= 0; ) {\n        syns[k] = (String) internedWords.get(syns[k]);\n      }\n      Object replacement = syns;\n      if (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n      word2Syns.remove(words[j]);\n      word2Syns.put(internedWords.get(words[j]), replacement);\n    }\n    \n    if (DEBUG) {\n      words = null;\n      allSynonyms = null;\n      internedWords = null;\n      allWords = null;\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    return word2Syns;\n  }\n\n","sourceOld":"  private HashMap optimize(HashMap word2Syns, HashMap internedWords) {\n    if (DEBUG) {\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    \n    // collect entries\n    int len = 0;\n    int size = word2Syns.size();\n    String[][] allSynonyms = new String[size][];\n    String[] words = new String[size];\n    Iterator iter = word2Syns.entrySet().iterator();\n    for (int j=0; j < size; j++) {\n      Map.Entry entry = (Map.Entry) iter.next();\n      allSynonyms[j] = (String[]) entry.getValue(); \n      words[j] = (String) entry.getKey();\n      len += words[j].length();\n    }\n    \n    // assemble large string containing all words\n    StringBuilder buf = new StringBuilder(len);\n    for (int j=0; j < size; j++) buf.append(words[j]);\n    String allWords = new String(buf.toString()); // ensure compact string across JDK versions\n    buf = null;\n    \n    // intern words at app level via memory-overlaid substrings\n    for (int p=0, j=0; j < size; j++) {\n      String word = words[j];\n      internedWords.put(word, allWords.substring(p, p + word.length()));\n      p += word.length();\n    }\n    \n    // replace words with interned words\n    for (int j=0; j < size; j++) {\n      String[] syns = allSynonyms[j];\n      for (int k=syns.length; --k >= 0; ) {\n        syns[k] = (String) internedWords.get(syns[k]);\n      }\n      Object replacement = syns;\n      if (syns.length == 1) replacement = syns[0]; // minimize memory consumption some more\n      word2Syns.remove(words[j]);\n      word2Syns.put(internedWords.get(words[j]), replacement);\n    }\n    \n    if (DEBUG) {\n      words = null;\n      allSynonyms = null;\n      internedWords = null;\n      allWords = null;\n      System.err.println(\"before gc\");\n      for (int i=0; i < 10; i++) System.gc();\n      System.err.println(\"after gc\");\n    }\n    return word2Syns;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4c9661df01b81c277277a01afbca7851557a2148":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["4c9661df01b81c277277a01afbca7851557a2148"],"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["4625cb7ffd7c9caaf2d62b206ba9a382d68da82c"]},"commit2Childs":{"4c9661df01b81c277277a01afbca7851557a2148":["7f68e24227d5556d33ee6d586fd9010cd9ff8bec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c9661df01b81c277277a01afbca7851557a2148"],"7f68e24227d5556d33ee6d586fd9010cd9ff8bec":["4625cb7ffd7c9caaf2d62b206ba9a382d68da82c"],"4625cb7ffd7c9caaf2d62b206ba9a382d68da82c":["d68e5c46e6a5ebdf4dafec4a123344092b915cc0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"d68e5c46e6a5ebdf4dafec4a123344092b915cc0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}