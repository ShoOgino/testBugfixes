{"path":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","commits":[{"id":"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","date":1406137403,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (\"test_s_dv\".equals(fieldName) || \"test_ss_dv\".equals(fieldName)) {\n      Arrays.sort(values, new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n          return String.valueOf(o1).compareTo(String.valueOf(o2));\n        }\n      });\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["b271c46c3637c193cc37983fc38592b1b99d5f1c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6d7fd8888854b7c6f30f35246057c92ddf5a750","date":1429938426,"type":3,"author":"Tomas Eduardo Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n          return String.valueOf(o1).compareTo(String.valueOf(o2));\n        }\n      });\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (\"test_s_dv\".equals(fieldName) || \"test_ss_dv\".equals(fieldName)) {\n      Arrays.sort(values, new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n          return String.valueOf(o1).compareTo(String.valueOf(o2));\n        }\n      });\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":["b271c46c3637c193cc37983fc38592b1b99d5f1c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, new Comparator<Integer>() {\n\n        @Override\n        public int compare(Integer o1, Integer o2) {\n          return String.valueOf(o1).compareTo(String.valueOf(o2));\n        }\n      });\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b271c46c3637c193cc37983fc38592b1b99d5f1c","date":1502322303,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second. The range could have values greater than \"max\", \n   * for example [Integer/Long/Float/Double].[MIN/MAX_VALUE,POSITIVE/NEGATIVE_INFINITY]\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   * If the field is a Date, a date range will be returned\n   * The range could also contain \"*\" as beginning and/or end of the range\n   */\n  private String[] getRandomRange(int max, String fieldName) {\n    Number[] values = new Number[2];\n    FieldType ft = h.getCore().getLatestSchema().getField(fieldName).getType();\n    if (ft.getNumberType() == null) {\n      assert ft instanceof StrField;\n      values[0] = randomInt(max);\n      values[1] = randomInt(max);\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      switch (ft.getNumberType()) {\n        case DOUBLE:\n          values[0] = raondomDouble(max);\n          values[1] = raondomDouble(max);\n          break;\n        case FLOAT:\n          values[0] = randomFloat(max);\n          values[1] = randomFloat(max);\n          break;\n        case INTEGER:\n          values[0] = randomInt(max);\n          values[1] = randomInt(max);\n          break;\n        case LONG:\n          values[0] = randomLong(max);\n          values[1] = randomLong(max);\n          break;\n        case DATE:\n          values[0] = randomMs(max);\n          values[1] = randomMs(max);\n          break;\n        default:\n          throw new AssertionError(\"Unexpected number type\");\n        \n      }\n      Arrays.sort(values);\n    }\n    String[] stringValues = new String[2];\n    if (rarely()) {\n      stringValues[0] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[0] = dateFormat.format(values[0]);\n      } else {\n        stringValues[0] = String.valueOf(values[0]);\n      }\n    }\n    if (rarely()) {\n      stringValues[1] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[1] = dateFormat.format(values[1]);\n      } else {\n        stringValues[1] = String.valueOf(values[1]);\n      }\n    }\n    return stringValues;\n  }\n\n","sourceOld":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","bugFix":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd","a6d7fd8888854b7c6f30f35246057c92ddf5a750"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second. The range could have values greater than \"max\", \n   * for example [Integer/Long/Float/Double].[MIN/MAX_VALUE,POSITIVE/NEGATIVE_INFINITY]\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   * If the field is a Date, a date range will be returned\n   * The range could also contain \"*\" as beginning and/or end of the range\n   */\n  private String[] getRandomRange(int max, String fieldName) {\n    Number[] values = new Number[2];\n    FieldType ft = h.getCore().getLatestSchema().getField(fieldName).getType();\n    if (ft.getNumberType() == null) {\n      assert ft instanceof StrField;\n      values[0] = randomInt(max);\n      values[1] = randomInt(max);\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      switch (ft.getNumberType()) {\n        case DOUBLE:\n          values[0] = raondomDouble(max);\n          values[1] = raondomDouble(max);\n          break;\n        case FLOAT:\n          values[0] = randomFloat(max);\n          values[1] = randomFloat(max);\n          break;\n        case INTEGER:\n          values[0] = randomInt(max);\n          values[1] = randomInt(max);\n          break;\n        case LONG:\n          values[0] = randomLong(max);\n          values[1] = randomLong(max);\n          break;\n        case DATE:\n          values[0] = randomMs(max);\n          values[1] = randomMs(max);\n          break;\n        default:\n          throw new AssertionError(\"Unexpected number type\");\n        \n      }\n      Arrays.sort(values);\n    }\n    String[] stringValues = new String[2];\n    if (rarely()) {\n      stringValues[0] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[0] = dateFormat.format(values[0]);\n      } else {\n        stringValues[0] = String.valueOf(values[0]);\n      }\n    }\n    if (rarely()) {\n      stringValues[1] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[1] = dateFormat.format(values[1]);\n      } else {\n        stringValues[1] = String.valueOf(values[1]);\n      }\n    }\n    return stringValues;\n  }\n\n","sourceOld":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","pathOld":"solr/core/src/test/org/apache/solr/request/TestIntervalFaceting#getRandomRange(int,String).mjava","sourceNew":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second. The range could have values greater than \"max\", \n   * for example [Integer/Long/Float/Double].[MIN/MAX_VALUE,POSITIVE/NEGATIVE_INFINITY]\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   * If the field is a Date, a date range will be returned\n   * The range could also contain \"*\" as beginning and/or end of the range\n   */\n  private String[] getRandomRange(int max, String fieldName) {\n    Number[] values = new Number[2];\n    FieldType ft = h.getCore().getLatestSchema().getField(fieldName).getType();\n    if (ft.getNumberType() == null) {\n      assert ft instanceof StrField;\n      values[0] = randomInt(max);\n      values[1] = randomInt(max);\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      switch (ft.getNumberType()) {\n        case DOUBLE:\n          values[0] = raondomDouble(max);\n          values[1] = raondomDouble(max);\n          break;\n        case FLOAT:\n          values[0] = randomFloat(max);\n          values[1] = randomFloat(max);\n          break;\n        case INTEGER:\n          values[0] = randomInt(max);\n          values[1] = randomInt(max);\n          break;\n        case LONG:\n          values[0] = randomLong(max);\n          values[1] = randomLong(max);\n          break;\n        case DATE:\n          values[0] = randomMs(max);\n          values[1] = randomMs(max);\n          break;\n        default:\n          throw new AssertionError(\"Unexpected number type\");\n        \n      }\n      Arrays.sort(values);\n    }\n    String[] stringValues = new String[2];\n    if (rarely()) {\n      stringValues[0] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[0] = dateFormat.format(values[0]);\n      } else {\n        stringValues[0] = String.valueOf(values[0]);\n      }\n    }\n    if (rarely()) {\n      stringValues[1] = \"*\";\n    } else {\n      if (ft.getNumberType() == NumberType.DATE) {\n        stringValues[1] = dateFormat.format(values[1]);\n      } else {\n        stringValues[1] = String.valueOf(values[1]);\n      }\n    }\n    return stringValues;\n  }\n\n","sourceOld":"  /**\n   * Returns a random range. It's guaranteed that the first\n   * number will be lower than the second, and both of them\n   * between 0 (inclusive) and <code>max</code> (exclusive).\n   * If the fieldName is \"test_s_dv\" or \"test_ss_dv\" (the\n   * two fields used for Strings), the comparison will be done\n   * alphabetically\n   */\n  private Integer[] getRandomRange(int max, String fieldName) {\n    Integer[] values = new Integer[2];\n    values[0] = random().nextInt(max);\n    values[1] = random().nextInt(max);\n    if (fieldName.startsWith(\"test_s\")) {\n      Arrays.sort(values, (o1, o2) -> String.valueOf(o1).compareTo(String.valueOf(o2)));\n    } else {\n      Arrays.sort(values);\n    }\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"58884af1f68e9d61c217c753fbd6266d86a63b14":["3a0c04b71951333291abc7f317109a6a5957bd28","b271c46c3637c193cc37983fc38592b1b99d5f1c"],"b271c46c3637c193cc37983fc38592b1b99d5f1c":["3a0c04b71951333291abc7f317109a6a5957bd28"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["3a0c04b71951333291abc7f317109a6a5957bd28","b271c46c3637c193cc37983fc38592b1b99d5f1c"],"a6d7fd8888854b7c6f30f35246057c92ddf5a750":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"3a0c04b71951333291abc7f317109a6a5957bd28":["a6d7fd8888854b7c6f30f35246057c92ddf5a750"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b271c46c3637c193cc37983fc38592b1b99d5f1c"]},"commit2Childs":{"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"b271c46c3637c193cc37983fc38592b1b99d5f1c":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["84b24f47dd3dfa4e2396cd6f819a35445b0a53fd"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"a6d7fd8888854b7c6f30f35246057c92ddf5a750":["3a0c04b71951333291abc7f317109a6a5957bd28"],"84b24f47dd3dfa4e2396cd6f819a35445b0a53fd":["a6d7fd8888854b7c6f30f35246057c92ddf5a750"],"3a0c04b71951333291abc7f317109a6a5957bd28":["58884af1f68e9d61c217c753fbd6266d86a63b14","b271c46c3637c193cc37983fc38592b1b99d5f1c","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}