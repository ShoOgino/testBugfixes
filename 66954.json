{"path":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a6ee6c302710254b6c2474ccd2755f9f2323ee3","date":1330700384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (fst.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!fst.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1dabaf49d63a1661287b2a7fe92b1fa1def38f2e","date":1331561772,"type":3,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre>\n   * PrintStream ps = new PrintStream(&quot;out.dot&quot;);\n   * fst.toDot(ps);\n   * ps.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","date":1339238489,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"87e78f3c129251e74ecc2ff73a32de0f27cf09d5","date":1358006150,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0","date":1358188277,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8917bfede3b4ca30f4305c1e391e9218959cd723","date":1358189662,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set(startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final FST.BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Integer.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n          final int node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get(arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set(arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add(arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader(0);\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<FST.Arc<T>>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<FST.Arc<T>>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<Integer>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<T>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is &gt; 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is > 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see \"http://www.graphviz.org/\"\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9cbc4730743fac2e69e7d622848778d3ad9f2151","date":1502282443,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is &gt; 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is &gt; 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.  If the FST is &gt; 2.1 GB in size\n   * then this method will throw strange exceptions.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target());\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput() == NO_OUTPUT ? null : startArc.nextFinalOutput();\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target()), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target() + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target();\n\n          fst.readFirstRealTargetArc(arc.target(), arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target() >= 0 && !seen.get((int) arc.target())) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput() != null && arc.nextFinalOutput() != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput());\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target()), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target());\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target());\n            }\n\n            String outs;\n            if (arc.output() != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output());\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput() != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput()) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label() != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target() + \" [label=\\\"\" + printableLabel(arc.label()) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/Util#[T]_toDot(FST[T],Writer,boolean,boolean).mjava","sourceNew":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target());\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput() == NO_OUTPUT ? null : startArc.nextFinalOutput();\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target()), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target() + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target();\n\n          fst.readFirstRealTargetArc(arc.target(), arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target() >= 0 && !seen.get((int) arc.target())) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput() != null && arc.nextFinalOutput() != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput());\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target()), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target());\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target());\n            }\n\n            String outs;\n            if (arc.output() != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output());\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput() != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput()) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label() != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target() + \" [label=\\\"\" + printableLabel(arc.label()) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","sourceOld":"  /**\n   * Dumps an {@link FST} to a GraphViz's <code>dot</code> language description\n   * for visualization. Example of use:\n   * \n   * <pre class=\"prettyprint\">\n   * PrintWriter pw = new PrintWriter(&quot;out.dot&quot;);\n   * Util.toDot(fst, pw, true, true);\n   * pw.close();\n   * </pre>\n   * \n   * and then, from command line:\n   * \n   * <pre>\n   * dot -Tpng -o out.png out.dot\n   * </pre>\n   * \n   * <p>\n   * Note: larger FSTs (a few thousand nodes) won't even\n   * render, don't bother.\n   * \n   * @param sameRank\n   *          If <code>true</code>, the resulting <code>dot</code> file will try\n   *          to order states in layers of breadth-first traversal. This may\n   *          mess up arcs, but makes the output FST's structure a bit clearer.\n   * \n   * @param labelStates\n   *          If <code>true</code> states will have labels equal to their offsets in their\n   *          binary format. Expands the graph considerably. \n   * \n   * @see <a href=\"http://www.graphviz.org/\">graphviz project</a>\n   */\n  public static <T> void toDot(FST<T> fst, Writer out, boolean sameRank, boolean labelStates) \n    throws IOException {    \n    final String expandedNodeColor = \"blue\";\n\n    // This is the start arc in the automaton (from the epsilon state to the first state \n    // with outgoing transitions.\n    final FST.Arc<T> startArc = fst.getFirstArc(new FST.Arc<T>());\n\n    // A queue of transitions to consider for the next level.\n    final List<FST.Arc<T>> thisLevelQueue = new ArrayList<>();\n\n    // A queue of transitions to consider when processing the next level.\n    final List<FST.Arc<T>> nextLevelQueue = new ArrayList<>();\n    nextLevelQueue.add(startArc);\n    //System.out.println(\"toDot: startArc: \" + startArc);\n    \n    // A list of states on the same level (for ranking).\n    final List<Integer> sameLevelStates = new ArrayList<>();\n\n    // A bitset of already seen states (target offset).\n    final BitSet seen = new BitSet();\n    seen.set((int) startArc.target);\n\n    // Shape for states.\n    final String stateShape = \"circle\";\n    final String finalStateShape = \"doublecircle\";\n\n    // Emit DOT prologue.\n    out.write(\"digraph FST {\\n\");\n    out.write(\"  rankdir = LR; splines=true; concentrate=true; ordering=out; ranksep=2.5; \\n\");\n\n    if (!labelStates) {\n      out.write(\"  node [shape=circle, width=.2, height=.2, style=filled]\\n\");      \n    }\n\n    emitDotState(out, \"initial\", \"point\", \"white\", \"\");\n\n    final T NO_OUTPUT = fst.outputs.getNoOutput();\n    final BytesReader r = fst.getBytesReader();\n\n    // final FST.Arc<T> scratchArc = new FST.Arc<>();\n\n    {\n      final String stateColor;\n      if (fst.isExpandedTarget(startArc, r)) {\n        stateColor = expandedNodeColor;\n      } else {\n        stateColor = null;\n      }\n\n      final boolean isFinal;\n      final T finalOutput;\n      if (startArc.isFinal()) {\n        isFinal = true;\n        finalOutput = startArc.nextFinalOutput == NO_OUTPUT ? null : startArc.nextFinalOutput;\n      } else {\n        isFinal = false;\n        finalOutput = null;\n      }\n      \n      emitDotState(out, Long.toString(startArc.target), isFinal ? finalStateShape : stateShape, stateColor, finalOutput == null ? \"\" : fst.outputs.outputToString(finalOutput));\n    }\n\n    out.write(\"  initial -> \" + startArc.target + \"\\n\");\n\n    int level = 0;\n\n    while (!nextLevelQueue.isEmpty()) {\n      // we could double buffer here, but it doesn't matter probably.\n      //System.out.println(\"next level=\" + level);\n      thisLevelQueue.addAll(nextLevelQueue);\n      nextLevelQueue.clear();\n\n      level++;\n      out.write(\"\\n  // Transitions and states at level: \" + level + \"\\n\");\n      while (!thisLevelQueue.isEmpty()) {\n        final FST.Arc<T> arc = thisLevelQueue.remove(thisLevelQueue.size() - 1);\n        //System.out.println(\"  pop: \" + arc);\n        if (FST.targetHasArcs(arc)) {\n          // scan all target arcs\n          //System.out.println(\"  readFirstTarget...\");\n\n          final long node = arc.target;\n\n          fst.readFirstRealTargetArc(arc.target, arc, r);\n\n          //System.out.println(\"    firstTarget: \" + arc);\n\n          while (true) {\n\n            //System.out.println(\"  cycle arc=\" + arc);\n            // Emit the unseen state and add it to the queue for the next level.\n            if (arc.target >= 0 && !seen.get((int) arc.target)) {\n\n              /*\n              boolean isFinal = false;\n              T finalOutput = null;\n              fst.readFirstTargetArc(arc, scratchArc);\n              if (scratchArc.isFinal() && fst.targetHasArcs(scratchArc)) {\n                // target is final\n                isFinal = true;\n                finalOutput = scratchArc.output == NO_OUTPUT ? null : scratchArc.output;\n                System.out.println(\"dot hit final label=\" + (char) scratchArc.label);\n              }\n              */\n              final String stateColor;\n              if (fst.isExpandedTarget(arc, r)) {\n                stateColor = expandedNodeColor;\n              } else {\n                stateColor = null;\n              }\n\n              final String finalOutput;\n              if (arc.nextFinalOutput != null && arc.nextFinalOutput != NO_OUTPUT) {\n                finalOutput = fst.outputs.outputToString(arc.nextFinalOutput);\n              } else {\n                finalOutput = \"\";\n              }\n\n              emitDotState(out, Long.toString(arc.target), stateShape, stateColor, finalOutput);\n              // To see the node address, use this instead:\n              //emitDotState(out, Integer.toString(arc.target), stateShape, stateColor, String.valueOf(arc.target));\n              seen.set((int) arc.target);\n              nextLevelQueue.add(new FST.Arc<T>().copyFrom(arc));\n              sameLevelStates.add((int) arc.target);\n            }\n\n            String outs;\n            if (arc.output != NO_OUTPUT) {\n              outs = \"/\" + fst.outputs.outputToString(arc.output);\n            } else {\n              outs = \"\";\n            }\n\n            if (!FST.targetHasArcs(arc) && arc.isFinal() && arc.nextFinalOutput != NO_OUTPUT) {\n              // Tricky special case: sometimes, due to\n              // pruning, the builder can [sillily] produce\n              // an FST with an arc into the final end state\n              // (-1) but also with a next final output; in\n              // this case we pull that output up onto this\n              // arc\n              outs = outs + \"/[\" + fst.outputs.outputToString(arc.nextFinalOutput) + \"]\";\n            }\n\n            final String arcColor;\n            if (arc.flag(FST.BIT_TARGET_NEXT)) {\n              arcColor = \"red\";\n            } else {\n              arcColor = \"black\";\n            }\n\n            assert arc.label != FST.END_LABEL;\n            out.write(\"  \" + node + \" -> \" + arc.target + \" [label=\\\"\" + printableLabel(arc.label) + outs + \"\\\"\" + (arc.isFinal() ? \" style=\\\"bold\\\"\" : \"\" ) + \" color=\\\"\" + arcColor + \"\\\"]\\n\");\n                   \n            // Break the loop if we're on the last arc of this state.\n            if (arc.isLast()) {\n              //System.out.println(\"    break\");\n              break;\n            }\n            fst.readNextRealArc(arc, r);\n          }\n        }\n      }\n\n      // Emit state ranking information.\n      if (sameRank && sameLevelStates.size() > 1) {\n        out.write(\"  {rank=same; \");\n        for (int state : sameLevelStates) {\n          out.write(state + \"; \");\n        }\n        out.write(\" }\\n\");\n      }\n      sameLevelStates.clear();                \n    }\n\n    // Emit terminating state (always there anyway).\n    out.write(\"  -1 [style=filled, color=black, shape=doublecircle, label=\\\"\\\"]\\n\\n\");\n    out.write(\"  {rank=sink; -1 }\\n\");\n    \n    out.write(\"}\\n\");\n    out.flush();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1dabaf49d63a1661287b2a7fe92b1fa1def38f2e"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["1dabaf49d63a1661287b2a7fe92b1fa1def38f2e"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["8917bfede3b4ca30f4305c1e391e9218959cd723","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8","d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["8b9fb5afeea0288262bffcc55bdcda8b5fa272c8"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"f8061ddd97f3352007d927dae445884a6f3d857b":["9cbc4730743fac2e69e7d622848778d3ad9f2151","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["9cbc4730743fac2e69e7d622848778d3ad9f2151"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["b1eb427f2c6beed80d1724555fc1db003ccf3030","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["b1eb427f2c6beed80d1724555fc1db003ccf3030","9cbc4730743fac2e69e7d622848778d3ad9f2151"],"1dabaf49d63a1661287b2a7fe92b1fa1def38f2e":["2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["9cbc4730743fac2e69e7d622848778d3ad9f2151","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c4015cd39dff8d4dec562d909f9766debac53aa6"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["38e3b736c7ca086d61b7dbb841c905ee115490da"],"8b9fb5afeea0288262bffcc55bdcda8b5fa272c8":["8917bfede3b4ca30f4305c1e391e9218959cd723","87e78f3c129251e74ecc2ff73a32de0f27cf09d5"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"d3c397b1515e745d8b12d70edfc0e17cb7eac7f0":["82557a475db3e0849171dc0be5b02e3ae0745ddb","8917bfede3b4ca30f4305c1e391e9218959cd723"],"8917bfede3b4ca30f4305c1e391e9218959cd723":["c4015cd39dff8d4dec562d909f9766debac53aa6"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","2a6ee6c302710254b6c2474ccd2755f9f2323ee3"],"9cbc4730743fac2e69e7d622848778d3ad9f2151":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"87e78f3c129251e74ecc2ff73a32de0f27cf09d5":["d3c397b1515e745d8b12d70edfc0e17cb7eac7f0"],"2a6ee6c302710254b6c2474ccd2755f9f2323ee3":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","1dabaf49d63a1661287b2a7fe92b1fa1def38f2e"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"1dabaf49d63a1661287b2a7fe92b1fa1def38f2e":["38e3b736c7ca086d61b7dbb841c905ee115490da","8b9fb5afeea0288262bffcc55bdcda8b5fa272c8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","c4015cd39dff8d4dec562d909f9766debac53aa6","f8061ddd97f3352007d927dae445884a6f3d857b","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}