{"path":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Bits,LeafCollector,DocsAndCost[]).mjava","commits":[{"id":"dd6be878365e339c75cc43ad7d5df95ab4ea21e5","date":1435762101,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Bits,LeafCollector,DocsAndCost[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Bits,LeafCollector,DocIdSetIterator[],LeafCollector[]).mjava","sourceNew":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      DocsAndCost dc = dims[0];\n      int docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n      \n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      dc = dims[1];\n      docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)\n            && (dc.twoPhase == null || dc.twoPhase.matches())) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != DocIdSetIterator.NO_MORE_DOCS) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for (int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        dc = dims[dim];\n        docID = dc.approximation.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID\n              && counts[slot] >= dim\n              && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= dim) {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n              //}\n              missingDims[slot] = dim+1;\n              counts[slot] = dim+2;\n            } else {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n              //}\n              counts[slot] = dim+1;\n            }\n          }\n\n          // TODO: sometimes use advance?\n          docID = dc.approximation.nextDoc();\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for (int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, dims);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(dims[missingDims[slot]].sidewaysLeafCollector);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Bits acceptDocs, LeafCollector collector, DocIdSetIterator[] disis, LeafCollector[] sidewaysCollectors) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      DocIdSetIterator disi = disis[0];\n      if (disi != null) {\n        int docID = disi.docID();\n        while (docID < nextChunkStart) {\n          if (acceptDocs == null || acceptDocs.get(docID)) {\n            int slot = docID & MASK;\n\n            if (docIDs[slot] != docID) {\n              seen.set(slot);\n              // Mark slot as valid:\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n              docIDs[slot] = docID;\n              missingDims[slot] = 1;\n              counts[slot] = 1;\n            }\n          }\n\n          docID = disi.nextDoc();\n        }\n      }\n      \n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      disi = disis[1];\n      if (disi != null) {\n        int docID = disi.docID();\n        while (docID < nextChunkStart) {\n          if (acceptDocs == null || acceptDocs.get(docID)) {\n            int slot = docID & MASK;\n\n            if (docIDs[slot] != docID) {\n              // Mark slot as valid:\n              seen.set(slot);\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n              docIDs[slot] = docID;\n              missingDims[slot] = 0;\n              counts[slot] = 1;\n            } else {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= 1) {\n                missingDims[slot] = 2;\n                counts[slot] = 2;\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n                //}\n              } else {\n                counts[slot] = 1;\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n                //}\n              }\n            }\n          }\n\n          docID = disi.nextDoc();\n        }\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != DocIdSetIterator.NO_MORE_DOCS) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for (int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        disi = disis[dim];\n        if (disi != null) {\n          int docID = disi.docID();\n          while (docID < nextChunkStart) {\n            int slot = docID & MASK;\n            if (docIDs[slot] == docID && counts[slot] >= dim) {\n              // TODO: single-valued dims will always be true\n              // below; we could somehow specialize\n              if (missingDims[slot] >= dim) {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n                //}\n                missingDims[slot] = dim+1;\n                counts[slot] = dim+2;\n              } else {\n                //if (DEBUG) {\n                //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n                //}\n                counts[slot] = dim+1;\n              }\n            }\n\n            // TODO: sometimes use advance?\n            docID = disi.nextDoc();\n          }\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for (int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, sidewaysCollectors);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(sidewaysCollectors[missingDims[slot]]);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dd748bb245633a8195281556bb0e68a6ea97d18","date":1449755030,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Bits,LeafCollector,DocsAndCost[]).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/DrillSidewaysScorer#doDrillDownAdvanceScoring(Bits,LeafCollector,DocsAndCost[]).mjava","sourceNew":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      DocsAndCost dc = dims[0];\n      int docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n      \n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      dc = dims[1];\n      docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)\n            && (dc.twoPhase == null || dc.twoPhase.matches())) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != DocIdSetIterator.NO_MORE_DOCS) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseIterator.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseIterator.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for (int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        dc = dims[dim];\n        docID = dc.approximation.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID\n              && counts[slot] >= dim\n              && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= dim) {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n              //}\n              missingDims[slot] = dim+1;\n              counts[slot] = dim+2;\n            } else {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n              //}\n              counts[slot] = dim+1;\n            }\n          }\n\n          // TODO: sometimes use advance?\n          docID = dc.approximation.nextDoc();\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for (int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, dims);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(dims[missingDims[slot]].sidewaysLeafCollector);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","sourceOld":"  /** Used when drill downs are highly constraining vs\n   *  baseQuery. */\n  private void doDrillDownAdvanceScoring(Bits acceptDocs, LeafCollector collector, DocsAndCost[] dims) throws IOException {\n    final int maxDoc = context.reader().maxDoc();\n    final int numDims = dims.length;\n\n    //if (DEBUG) {\n    //  System.out.println(\"  doDrillDownAdvanceScoring\");\n    //}\n\n    // TODO: maybe a class like BS, instead of parallel arrays\n    int[] filledSlots = new int[CHUNK];\n    int[] docIDs = new int[CHUNK];\n    float[] scores = new float[CHUNK];\n    int[] missingDims = new int[CHUNK];\n    int[] counts = new int[CHUNK];\n\n    docIDs[0] = -1;\n    int nextChunkStart = CHUNK;\n\n    final FixedBitSet seen = new FixedBitSet(CHUNK);\n\n    while (true) {\n      //if (DEBUG) {\n      //  System.out.println(\"\\ncycle nextChunkStart=\" + nextChunkStart + \" docIds[0]=\" + docIDs[0]);\n      //}\n\n      // First dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim0\");\n      //}\n      DocsAndCost dc = dims[0];\n      int docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            seen.set(slot);\n            // Mark slot as valid:\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 1;\n            counts[slot] = 1;\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n      \n      // Second dim:\n      //if (DEBUG) {\n      //  System.out.println(\"  dim1\");\n      //}\n      dc = dims[1];\n      docID = dc.approximation.docID();\n      while (docID < nextChunkStart) {\n        if (acceptDocs == null || acceptDocs.get(docID)\n            && (dc.twoPhase == null || dc.twoPhase.matches())) {\n          int slot = docID & MASK;\n\n          if (docIDs[slot] != docID) {\n            // Mark slot as valid:\n            seen.set(slot);\n            //if (DEBUG) {\n            //  System.out.println(\"    set docID=\" + docID + \" missingDim=0 id=\" + context.reader().document(docID).get(\"id\"));\n            //}\n            docIDs[slot] = docID;\n            missingDims[slot] = 0;\n            counts[slot] = 1;\n          } else {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= 1) {\n              missingDims[slot] = 2;\n              counts[slot] = 2;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=2 id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            } else {\n              counts[slot] = 1;\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missingDim=\" + missingDims[slot] + \" id=\" + context.reader().document(docID).get(\"id\"));\n              //}\n            }\n          }\n        }\n\n        docID = dc.approximation.nextDoc();\n      }\n\n      // After this we can \"upgrade\" to conjunction, because\n      // any doc not seen by either dim 0 or dim 1 cannot be\n      // a hit or a near miss:\n\n      //if (DEBUG) {\n      //  System.out.println(\"  baseScorer\");\n      //}\n\n      // Fold in baseScorer, using advance:\n      int filledCount = 0;\n      int slot0 = 0;\n      while (slot0 < CHUNK && (slot0 = seen.nextSetBit(slot0)) != DocIdSetIterator.NO_MORE_DOCS) {\n        int ddDocID = docIDs[slot0];\n        assert ddDocID != -1;\n\n        int baseDocID = baseScorer.docID();\n        if (baseDocID < ddDocID) {\n          baseDocID = baseScorer.advance(ddDocID);\n        }\n        if (baseDocID == ddDocID) {\n          //if (DEBUG) {\n          //  System.out.println(\"    keep docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          scores[slot0] = baseScorer.score();\n          filledSlots[filledCount++] = slot0;\n          counts[slot0]++;\n        } else {\n          //if (DEBUG) {\n          //  System.out.println(\"    no docID=\" + ddDocID + \" id=\" + context.reader().document(ddDocID).get(\"id\"));\n          //}\n          docIDs[slot0] = -1;\n\n          // TODO: we could jump slot0 forward to the\n          // baseDocID ... but we'd need to set docIDs for\n          // intervening slots to -1\n        }\n        slot0++;\n      }\n      seen.clear(0, CHUNK);\n\n      if (filledCount == 0) {\n        if (nextChunkStart >= maxDoc) {\n          break;\n        }\n        nextChunkStart += CHUNK;\n        continue;\n      }\n      \n      // TODO: factor this out & share w/ union scorer,\n      // except we start from dim=2 instead:\n      for (int dim=2;dim<numDims;dim++) {\n        //if (DEBUG) {\n        //  System.out.println(\"  dim=\" + dim + \" [\" + dims[dim].dim + \"]\");\n        //}\n        dc = dims[dim];\n        docID = dc.approximation.docID();\n        while (docID < nextChunkStart) {\n          int slot = docID & MASK;\n          if (docIDs[slot] == docID\n              && counts[slot] >= dim\n              && (dc.twoPhase == null || dc.twoPhase.matches())) {\n            // TODO: single-valued dims will always be true\n            // below; we could somehow specialize\n            if (missingDims[slot] >= dim) {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" count=\" + (dim+2));\n              //}\n              missingDims[slot] = dim+1;\n              counts[slot] = dim+2;\n            } else {\n              //if (DEBUG) {\n              //  System.out.println(\"    set docID=\" + docID + \" missing count=\" + (dim+1));\n              //}\n              counts[slot] = dim+1;\n            }\n          }\n\n          // TODO: sometimes use advance?\n          docID = dc.approximation.nextDoc();\n        }\n      }\n\n      // Collect:\n      //if (DEBUG) {\n      //  System.out.println(\"  now collect: \" + filledCount + \" hits\");\n      //}\n      for (int i=0;i<filledCount;i++) {\n        int slot = filledSlots[i];\n        collectDocID = docIDs[slot];\n        collectScore = scores[slot];\n        //if (DEBUG) {\n        //  System.out.println(\"    docID=\" + docIDs[slot] + \" count=\" + counts[slot]);\n        //}\n        if (counts[slot] == 1+numDims) {\n          collectHit(collector, dims);\n        } else if (counts[slot] == numDims) {\n          collectNearMiss(dims[missingDims[slot]].sidewaysLeafCollector);\n        }\n      }\n\n      if (nextChunkStart >= maxDoc) {\n        break;\n      }\n\n      nextChunkStart += CHUNK;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7dd748bb245633a8195281556bb0e68a6ea97d18":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7dd748bb245633a8195281556bb0e68a6ea97d18"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["dd6be878365e339c75cc43ad7d5df95ab4ea21e5"],"7dd748bb245633a8195281556bb0e68a6ea97d18":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"dd6be878365e339c75cc43ad7d5df95ab4ea21e5":["7dd748bb245633a8195281556bb0e68a6ea97d18"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}