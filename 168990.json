{"path":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ab99e8c71442b92c320e218141dee04a9b91ce8","date":1269203801,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new WhitespaceAnalyzer(\n                    TEST_VERSION_CURRENT)).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            w = new IndexWriter(dir, new IndexWriterConfig(TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDocs(2));\n            ((LogMergePolicy) w.getMergePolicy()).setMergeFactor(2);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d572389229127c297dd1fa5ce4758e1cec41e799","date":1273610938,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new WhitespaceAnalyzer(\n                    TEST_VERSION_CURRENT)).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a2c21de83b3686a5c88d3b00c3b8b3e8d8475c9","date":1280394491,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      try {\n        w.rollback();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6fe59e831a8e6dd46d16a75a9fd0612b99e9f5cc","date":1280408212,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      try {\n        w.rollback();\n      } catch (IOException ioe) {\n        throw new RuntimeException(ioe);\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b21422ff1d1d56499dec481f193b402e5e8def5b","date":1281472367,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c","date":1281477834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MockRAMDirectory dir = new MockRAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c","date":1281646583,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      MockRAMDirectory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      dir.close();\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      MockRAMDirectory dir = new MockRAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a05409176bd65129d67a785ee70e881e238a9aef","date":1282582843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      Directory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      MockRAMDirectory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      dir.close();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3eaa8ca351aa7eefa5bd5bf249e9dd9bb0830c54","date":1282658201,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      Directory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      Directory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"deb4fe59e35ea6bac0ee825142d40a04846fe573","date":1282737351,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      Directory dir;\n      try { \n        dir = newDirectory(random); \n      } catch (IOException e) { throw new RuntimeException(e); }\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(random, \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"132903c28af3aa6f67284b78de91c0f0a99488c2","date":1284282129,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"53a31399f2471493d67b19a95c028a74e0113b6a","date":1289817072,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9ab1f5591dc05f1f2b5407d809c9699f75554a32","date":1290008586,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      RAMDirectory dir = new RAMDirectory();\n      IndexWriter w = null;\n      boolean first = true;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = new IndexWriterConfig(\n                TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            //((ConcurrentMergeScheduler) w.getMergeScheduler()).setSuppressExceptions();\n            if (!first && !allowInterrupt) {\n              // tell main thread it can interrupt us any time,\n              // starting now\n              allowInterrupt = true;\n            }\n\n            Document doc = new Document();\n            doc.add(new Field(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              w.commit();\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            if (first && !allowInterrupt) {\n              // Strangely, if we interrupt a thread before\n              // all classes are loaded, the class loader\n              // seems to do scary things with the interrupt\n              // status.  In java 1.5, it'll throw an\n              // incorrect ClassNotFoundException.  In java\n              // 1.6, it'll silently clear the interrupt.\n              // So, on first iteration through here we\n              // don't open ourselves up for interrupts\n              // until we've done the above loop.\n              allowInterrupt = true;\n              first = false;\n            }\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n          \n          // Make sure IW cleared the interrupted bit\n          // TODO: remove that false once test is fixed for real\n          if (false && interrupted()) {\n            System.out.println(\"FAILED; InterruptedException hit but thread.interrupted() was true\");\n            e.printStackTrace(System.out);\n            failed = true;\n            break;\n          }\n\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            ((LogMergePolicy) conf.getMergePolicy()).setMergeFactor(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2c5f0cb44df114db4228c8f77861714b5cabaea","date":1302542431,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5d98a6b014b664e716eb3af578734f1ba04405bc","date":1305050526,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1fff768faeea6949a7d8937f06983038d4de0cd1","date":1305374899,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":["2cc0964e95f9f205bbfc7259e04d6a78b55cd84a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory()); \n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(true) {\n            if (w != null) {\n              w.close();\n            }\n            IndexWriterConfig conf = newIndexWriterConfig( \n                                                          TEST_VERSION_CURRENT, new MockAnalyzer()).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        try {\n          w.rollback();\n        } catch (IOException ioe) {\n          throw new RuntimeException(ioe);\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try { \n        dir.close();\n      } catch (IOException e) { \n        throw new RuntimeException(e); \n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efb7a19703a037c29e30440260d393500febc1f4","date":1306648116,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", Field.Store.YES, Field.Index.ANALYZED));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7719bda090a2ae5bab940a27ba7bb9054b29818","date":1315503197,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n            w.setInfoStream(VERBOSE ? System.out : null);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n            w.setInfoStream(VERBOSE ? System.out : null);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c5b026d03cbbb03ca4c0b97d14e9839682281dc","date":1323049298,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3615ce4a1f785ae1b779244de52c6a7d99227e60","date":1323422019,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","date":1323437438,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir, true).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir, true);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriter.IndexerThreadInterrupt#run().mjava","sourceNew":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n      // LUCENE-2239: won't work with NIOFS/MMAP\n      Directory dir = new MockDirectoryWrapper(random, new RAMDirectory());\n      IndexWriter w = null;\n      while(!finish) {\n        try {\n\n          while(!finish) {\n            if (w != null) {\n              w.close();\n              w = null;\n            }\n            IndexWriterConfig conf = newIndexWriterConfig(\n                                                          TEST_VERSION_CURRENT, new MockAnalyzer(random)).setMaxBufferedDocs(2);\n            w = new IndexWriter(dir, conf);\n\n            Document doc = new Document();\n            doc.add(newField(\"field\", \"some text contents\", storedTextType));\n            for(int i=0;i<100;i++) {\n              w.addDocument(doc);\n              if (i%10 == 0) {\n                w.commit();\n              }\n            }\n            w.close();\n            w = null;\n            _TestUtil.checkIndex(dir);\n            IndexReader.open(dir).close();\n\n            // Strangely, if we interrupt a thread before\n            // all classes are loaded, the class loader\n            // seems to do scary things with the interrupt\n            // status.  In java 1.5, it'll throw an\n            // incorrect ClassNotFoundException.  In java\n            // 1.6, it'll silently clear the interrupt.\n            // So, on first iteration through here we\n            // don't open ourselves up for interrupts\n            // until we've done the above loop.\n            allowInterrupt = true;\n          }\n        } catch (ThreadInterruptedException re) {\n          if (VERBOSE) {\n            System.out.println(\"TEST: got interrupt\");\n            re.printStackTrace(System.out);\n          }\n          Throwable e = re.getCause();\n          assertTrue(e instanceof InterruptedException);\n          if (finish) {\n            break;\n          }\n        } catch (Throwable t) {\n          System.out.println(\"FAILED; unexpected exception\");\n          t.printStackTrace(System.out);\n          failed = true;\n          break;\n        }\n      }\n\n      if (!failed) {\n        // clear interrupt state:\n        Thread.interrupted();\n        if (w != null) {\n          try {\n            w.rollback();\n          } catch (IOException ioe) {\n            throw new RuntimeException(ioe);\n          }\n        }\n\n        try {\n          _TestUtil.checkIndex(dir);\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"CheckIndex FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n        try {\n          IndexReader r = IndexReader.open(dir);\n          //System.out.println(\"doc count=\" + r.numDocs());\n          r.close();\n        } catch (Exception e) {\n          failed = true;\n          System.out.println(\"IndexReader.open FAILED: unexpected exception\");\n          e.printStackTrace(System.out);\n        }\n      }\n      try {\n        dir.close();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":["06584e6e98d592b34e1329b384182f368d2025e8","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"efb7a19703a037c29e30440260d393500febc1f4":["1fff768faeea6949a7d8937f06983038d4de0cd1"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["06584e6e98d592b34e1329b384182f368d2025e8"],"132903c28af3aa6f67284b78de91c0f0a99488c2":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["d572389229127c297dd1fa5ce4758e1cec41e799","53a31399f2471493d67b19a95c028a74e0113b6a"],"c19f985e36a65cc969e8e564fe337a0d41512075":["53a31399f2471493d67b19a95c028a74e0113b6a"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["c19f985e36a65cc969e8e564fe337a0d41512075"],"53a31399f2471493d67b19a95c028a74e0113b6a":["132903c28af3aa6f67284b78de91c0f0a99488c2"],"deb4fe59e35ea6bac0ee825142d40a04846fe573":["3eaa8ca351aa7eefa5bd5bf249e9dd9bb0830c54"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a3776dccca01c11e7046323cfad46a3b4a471233","efb7a19703a037c29e30440260d393500febc1f4"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["deb4fe59e35ea6bac0ee825142d40a04846fe573"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["9ab1f5591dc05f1f2b5407d809c9699f75554a32","c19f985e36a65cc969e8e564fe337a0d41512075"],"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c":["b21422ff1d1d56499dec481f193b402e5e8def5b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a05409176bd65129d67a785ee70e881e238a9aef":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5d98a6b014b664e716eb3af578734f1ba04405bc"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["efb7a19703a037c29e30440260d393500febc1f4"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["6fe59e831a8e6dd46d16a75a9fd0612b99e9f5cc"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["c3a8a449466c1ff7ce2274fe73dab487256964b4","efb7a19703a037c29e30440260d393500febc1f4"],"7a2c21de83b3686a5c88d3b00c3b8b3e8d8475c9":["d572389229127c297dd1fa5ce4758e1cec41e799"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["132903c28af3aa6f67284b78de91c0f0a99488c2","53a31399f2471493d67b19a95c028a74e0113b6a"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"06584e6e98d592b34e1329b384182f368d2025e8":["f7719bda090a2ae5bab940a27ba7bb9054b29818"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"d572389229127c297dd1fa5ce4758e1cec41e799":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["f2c5f0cb44df114db4228c8f77861714b5cabaea","962d04139994fce5193143ef35615499a9a96d78"],"962d04139994fce5193143ef35615499a9a96d78":["bde51b089eb7f86171eb3406e38a274743f9b7ac","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"5d98a6b014b664e716eb3af578734f1ba04405bc":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"f7719bda090a2ae5bab940a27ba7bb9054b29818":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","1fff768faeea6949a7d8937f06983038d4de0cd1"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c19f985e36a65cc969e8e564fe337a0d41512075","1fff768faeea6949a7d8937f06983038d4de0cd1"],"1fff768faeea6949a7d8937f06983038d4de0cd1":["5d98a6b014b664e716eb3af578734f1ba04405bc"],"3eaa8ca351aa7eefa5bd5bf249e9dd9bb0830c54":["a05409176bd65129d67a785ee70e881e238a9aef"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["06584e6e98d592b34e1329b384182f368d2025e8","1c5b026d03cbbb03ca4c0b97d14e9839682281dc"],"6fe59e831a8e6dd46d16a75a9fd0612b99e9f5cc":["7a2c21de83b3686a5c88d3b00c3b8b3e8d8475c9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"efb7a19703a037c29e30440260d393500febc1f4":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","1509f151d7692d84fae414b2b799ac06ba60fcb4","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"1c5b026d03cbbb03ca4c0b97d14e9839682281dc":["3615ce4a1f785ae1b779244de52c6a7d99227e60"],"132903c28af3aa6f67284b78de91c0f0a99488c2":["53a31399f2471493d67b19a95c028a74e0113b6a","9ab1f5591dc05f1f2b5407d809c9699f75554a32"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c19f985e36a65cc969e8e564fe337a0d41512075":["f2c5f0cb44df114db4228c8f77861714b5cabaea","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","a3776dccca01c11e7046323cfad46a3b4a471233"],"53a31399f2471493d67b19a95c028a74e0113b6a":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075","9ab1f5591dc05f1f2b5407d809c9699f75554a32"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","962d04139994fce5193143ef35615499a9a96d78"],"deb4fe59e35ea6bac0ee825142d40a04846fe573":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"1f653cfcf159baeaafe5d01682a911e95bba4012":["132903c28af3aa6f67284b78de91c0f0a99488c2"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a05409176bd65129d67a785ee70e881e238a9aef":["3eaa8ca351aa7eefa5bd5bf249e9dd9bb0830c54"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["f7719bda090a2ae5bab940a27ba7bb9054b29818"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["1a2e46fd1b7cbc52d7d6461a6ef99e7107ae2a9c"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["962d04139994fce5193143ef35615499a9a96d78"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[],"7a2c21de83b3686a5c88d3b00c3b8b3e8d8475c9":["6fe59e831a8e6dd46d16a75a9fd0612b99e9f5cc"],"9ab1f5591dc05f1f2b5407d809c9699f75554a32":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["a05409176bd65129d67a785ee70e881e238a9aef"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["d572389229127c297dd1fa5ce4758e1cec41e799"],"06584e6e98d592b34e1329b384182f368d2025e8":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","1c5b026d03cbbb03ca4c0b97d14e9839682281dc","3615ce4a1f785ae1b779244de52c6a7d99227e60"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"d572389229127c297dd1fa5ce4758e1cec41e799":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","7a2c21de83b3686a5c88d3b00c3b8b3e8d8475c9"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5d98a6b014b664e716eb3af578734f1ba04405bc"],"962d04139994fce5193143ef35615499a9a96d78":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"5d98a6b014b664e716eb3af578734f1ba04405bc":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb","1fff768faeea6949a7d8937f06983038d4de0cd1"],"f7719bda090a2ae5bab940a27ba7bb9054b29818":["06584e6e98d592b34e1329b384182f368d2025e8"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["2e10cb22a8bdb44339e282925a29182bb2f3174d"],"a3776dccca01c11e7046323cfad46a3b4a471233":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"1fff768faeea6949a7d8937f06983038d4de0cd1":["efb7a19703a037c29e30440260d393500febc1f4","c3a8a449466c1ff7ce2274fe73dab487256964b4","a3776dccca01c11e7046323cfad46a3b4a471233"],"3615ce4a1f785ae1b779244de52c6a7d99227e60":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"3eaa8ca351aa7eefa5bd5bf249e9dd9bb0830c54":["deb4fe59e35ea6bac0ee825142d40a04846fe573"],"6fe59e831a8e6dd46d16a75a9fd0612b99e9f5cc":["b21422ff1d1d56499dec481f193b402e5e8def5b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ba5bc70a1fc1e0abc1eb4171af0d6f2532711c00","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","2e10cb22a8bdb44339e282925a29182bb2f3174d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}