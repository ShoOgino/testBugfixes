{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","commits":[{"id":"9664831d785795f0f380fccc6db560efb979fdbb","date":1526559002,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","pathOld":"/dev/null","sourceNew":"  public void testUpdateSingleDocWithThreads() throws IOException, BrokenBarrierException, InterruptedException {\n    try (Directory dir = newDirectory();\n         RandomIndexWriter writer = new RandomIndexWriter(random(), dir,\n             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001))) {\n      Thread[] threads = new Thread[3 + random().nextInt(3)];\n      AtomicInteger done = new AtomicInteger(0);\n      CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n      writer.updateDocument(new Term(\"id\", \"1\"), doc);\n      int itersPerThread = 100 + random().nextInt(2000);\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread(() -> {\n          try {\n            barrier.await();\n            for (int iters = 0; iters < itersPerThread; iters++) {\n              Document d = new Document();\n              d.add(new StringField(\"id\", \"1\", Field.Store.NO));\n              writer.updateDocument(new Term(\"id\", \"1\"), d);\n            }\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            done.incrementAndGet();\n          }\n        });\n        threads[i].start();\n      }\n      DirectoryReader open = DirectoryReader.open(writer.w);\n      assertEquals(open.numDocs(), 1);\n      barrier.await();\n      try {\n        do {\n          DirectoryReader newReader = DirectoryReader.openIfChanged(open);\n          if (newReader != null) {\n            open.close();\n            open = newReader;\n          }\n          assertEquals(open.numDocs(), 1);\n        } while (done.get() < threads.length);\n      } finally {\n        open.close();\n        for (int i = 0; i < threads.length; i++) {\n          threads[i].join();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["10dae974eb4de913f4a2075cd10fb6dfcba04a99"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10dae974eb4de913f4a2075cd10fb6dfcba04a99","date":1528877401,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","sourceNew":"  public void testUpdateSingleDocWithThreads() throws Exception {\n    stressUpdateSingleDocWithThreads(false, rarely());\n  }\n\n","sourceOld":"  public void testUpdateSingleDocWithThreads() throws IOException, BrokenBarrierException, InterruptedException {\n    try (Directory dir = newDirectory();\n         RandomIndexWriter writer = new RandomIndexWriter(random(), dir,\n             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001))) {\n      Thread[] threads = new Thread[3 + random().nextInt(3)];\n      AtomicInteger done = new AtomicInteger(0);\n      CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n      writer.updateDocument(new Term(\"id\", \"1\"), doc);\n      int itersPerThread = 100 + random().nextInt(2000);\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread(() -> {\n          try {\n            barrier.await();\n            for (int iters = 0; iters < itersPerThread; iters++) {\n              Document d = new Document();\n              d.add(new StringField(\"id\", \"1\", Field.Store.NO));\n              writer.updateDocument(new Term(\"id\", \"1\"), d);\n            }\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            done.incrementAndGet();\n          }\n        });\n        threads[i].start();\n      }\n      DirectoryReader open = DirectoryReader.open(writer.w);\n      assertEquals(open.numDocs(), 1);\n      barrier.await();\n      try {\n        do {\n          DirectoryReader newReader = DirectoryReader.openIfChanged(open);\n          if (newReader != null) {\n            open.close();\n            open = newReader;\n          }\n          assertEquals(open.numDocs(), 1);\n        } while (done.get() < threads.length);\n      } finally {\n        open.close();\n        for (int i = 0; i < threads.length; i++) {\n          threads[i].join();\n        }\n      }\n    }\n  }\n\n","bugFix":["9664831d785795f0f380fccc6db560efb979fdbb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","sourceNew":"  public void testUpdateSingleDocWithThreads() throws Exception {\n    stressUpdateSingleDocWithThreads(false, rarely());\n  }\n\n","sourceOld":"  public void testUpdateSingleDocWithThreads() throws IOException, BrokenBarrierException, InterruptedException {\n    try (Directory dir = newDirectory();\n         RandomIndexWriter writer = new RandomIndexWriter(random(), dir,\n             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001))) {\n      Thread[] threads = new Thread[3 + random().nextInt(3)];\n      AtomicInteger done = new AtomicInteger(0);\n      CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n      writer.updateDocument(new Term(\"id\", \"1\"), doc);\n      int itersPerThread = 100 + random().nextInt(2000);\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread(() -> {\n          try {\n            barrier.await();\n            for (int iters = 0; iters < itersPerThread; iters++) {\n              Document d = new Document();\n              d.add(new StringField(\"id\", \"1\", Field.Store.NO));\n              writer.updateDocument(new Term(\"id\", \"1\"), d);\n            }\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            done.incrementAndGet();\n          }\n        });\n        threads[i].start();\n      }\n      DirectoryReader open = DirectoryReader.open(writer.w);\n      assertEquals(open.numDocs(), 1);\n      barrier.await();\n      try {\n        do {\n          DirectoryReader newReader = DirectoryReader.openIfChanged(open);\n          if (newReader != null) {\n            open.close();\n            open = newReader;\n          }\n          assertEquals(open.numDocs(), 1);\n        } while (done.get() < threads.length);\n      } finally {\n        open.close();\n        for (int i = 0; i < threads.length; i++) {\n          threads[i].join();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterWithThreads#testUpdateSingleDocWithThreads().mjava","sourceNew":"  public void testUpdateSingleDocWithThreads() throws Exception {\n    stressUpdateSingleDocWithThreads(false, rarely());\n  }\n\n","sourceOld":"  public void testUpdateSingleDocWithThreads() throws IOException, BrokenBarrierException, InterruptedException {\n    try (Directory dir = newDirectory();\n         RandomIndexWriter writer = new RandomIndexWriter(random(), dir,\n             newIndexWriterConfig().setMaxBufferedDocs(-1).setRAMBufferSizeMB(0.00001))) {\n      Thread[] threads = new Thread[3 + random().nextInt(3)];\n      AtomicInteger done = new AtomicInteger(0);\n      CyclicBarrier barrier = new CyclicBarrier(threads.length + 1);\n      Document doc = new Document();\n      doc.add(new StringField(\"id\", \"1\", Field.Store.NO));\n      writer.updateDocument(new Term(\"id\", \"1\"), doc);\n      int itersPerThread = 100 + random().nextInt(2000);\n      for (int i = 0; i < threads.length; i++) {\n        threads[i] = new Thread(() -> {\n          try {\n            barrier.await();\n            for (int iters = 0; iters < itersPerThread; iters++) {\n              Document d = new Document();\n              d.add(new StringField(\"id\", \"1\", Field.Store.NO));\n              writer.updateDocument(new Term(\"id\", \"1\"), d);\n            }\n          } catch (Exception e) {\n            throw new AssertionError(e);\n          } finally {\n            done.incrementAndGet();\n          }\n        });\n        threads[i].start();\n      }\n      DirectoryReader open = DirectoryReader.open(writer.w);\n      assertEquals(open.numDocs(), 1);\n      barrier.await();\n      try {\n        do {\n          DirectoryReader newReader = DirectoryReader.openIfChanged(open);\n          if (newReader != null) {\n            open.close();\n            open = newReader;\n          }\n          assertEquals(open.numDocs(), 1);\n        } while (done.get() < threads.length);\n      } finally {\n        open.close();\n        for (int i = 0; i < threads.length; i++) {\n          threads[i].join();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["9664831d785795f0f380fccc6db560efb979fdbb","10dae974eb4de913f4a2075cd10fb6dfcba04a99"],"9664831d785795f0f380fccc6db560efb979fdbb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"10dae974eb4de913f4a2075cd10fb6dfcba04a99":["9664831d785795f0f380fccc6db560efb979fdbb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["10dae974eb4de913f4a2075cd10fb6dfcba04a99"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["9664831d785795f0f380fccc6db560efb979fdbb","10dae974eb4de913f4a2075cd10fb6dfcba04a99"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"9664831d785795f0f380fccc6db560efb979fdbb":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","10dae974eb4de913f4a2075cd10fb6dfcba04a99","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9664831d785795f0f380fccc6db560efb979fdbb"],"10dae974eb4de913f4a2075cd10fb6dfcba04a99":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}