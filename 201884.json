{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d","date":1330786058,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","date":1331075828,"type":3,"author":"Ryan McKinley","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e2fe35ac47f8f51356d6c1724455d18f31c94fae","date":1337966698,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      // even in non zk mode, tests simulate updates from a leader\n      isLeader = !req.getParams().getBool(SEEN_LEADER, false);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      if (isLeader) {\n        params.set(SEEN_LEADER, true);\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2","date":1342630362,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6013b4c7388f1627659c8f96c44abd10a294d3a6","date":1346343796,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":["77331c0e66a5501a256626c16dba384276ff05bf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","date":1346817835,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      if (isLeader && !req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n        log.error(\"Abort sending request to replicas, we are no longer leader\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Abort sending request to replicas, we are no longer leader\");\n      }\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":["a6378064655e76cd7b908b1cab4ce425b384b508"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6378064655e76cd7b908b1cab4ce425b384b508","date":1347656715,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      if (isLeader && !req.getCore().getCoreDescriptor().getCloudDescriptor().isLeader()) {\n        log.error(\"Abort sending request to replicas, we are no longer leader\");\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE, \"Abort sending request to replicas, we are no longer leader\");\n      }\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e19067e820b148e8dc0b240da4f2771cf7b68252","date":1347730768,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      // clone the original doc\n      SolrInputDocument clonedDoc = cmd.solrDoc.deepCopy();\n      dropCmd = versionAdd(cmd, clonedDoc);\n      cmd.solrDoc = clonedDoc;\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2806236d9dfa336ac413d3724a4123e7cf4d1e93","date":1348631501,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(req.getParams());\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      params.remove(\"commit\"); // this will be distributed from the local commit\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5a558d54519c651068ddb202f03befefb1514a7","date":1354382006,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7754464847b06ced605515bd48219280ede29e9","date":1354586462,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    // TODO: check for id field?\n    int hash = 0;\n    if (zkEnabled) {\n      zkCheck();\n      hash = hash(cmd);\n      nodes = setupRequest(hash);\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0beaed456aa3358e5e4a99ea2aea994ef6c81de3","date":1365434191,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      if (forwardToSubShard)  {\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8f1ea787bab5bdb5e72685e55424898da05509b6","date":1370289750,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      \n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM, \n                 (isLeader ? \n                  DistribPhase.FROMLEADER.toString() : \n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n      if (forwardToSubShard)  {\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"96adbab674ae121f8b6b3e10474070b4bd97a219","date":1373614333,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"91e069c492cf4895697ef7b81df0ffb9a8bd4b48","date":1382134253,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.syncAdd(cmd, subShardLeader, params);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77331c0e66a5501a256626c16dba384276ff05bf","date":1384494254,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0","date":1385584801,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      } else if (log.isDebugEnabled()) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a51acc2e27bfb18091f9395494aebe82266f7ce7","date":1385611742,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      } else if (log.isDebugEnabled()) {\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.parent\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(\"distrib.from.collection\", req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(\"distrib.from.shard\", req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      if (isLeader || isSubShardLeader) {\n        params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n      }\n\n      params.set(\"distrib.from\", ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14d5815ecbef89580f5c48990bcd433f04f8563a","date":1399564106,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d22d0f5940f155267b250876fa797ff69e8e6e7","date":1400540695,"type":3,"author":"Timothy Potter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7605579001505896d48b07160075a5c8b8e128e","date":1400758727,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n\n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      cmdDistrib.distribAdd(cmd, nodes, params);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRef();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7350fba633b826986454e97668c5ad03b46bcaca","date":1446484423,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>();\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","date":1452195469,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n    \n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n      \n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f9beac30228721abdefa5efd0601081e7c3421e","date":1486468693,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"63c7ac6ed76316ffb50323bdf5c5bd973099b8c3","date":1486470155,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb734912d92a3243e7b18a32826749220d52d06c","date":1487470801,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n      }\n      cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14a570ea289e0d989057de081e0a4fb0255f4a53","date":1508372334,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        for (Node subShardLeader : subShardLeaders) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(subShardLeader), params, true);\n        }\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        \n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        \n        for (Node nodesByRoutingRule : nodesByRoutingRules) {\n          cmdDistrib.distribAdd(cmd, Collections.singletonList(nodesByRoutingRule), params, true);\n        }\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"601f914e4448cab7640fecfb5d15f8f2e2af0bf6","date":1508947828,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, req.getCore().getCoreDescriptor().getCloudDescriptor().getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, req.getCore().getCoreDescriptor().getCloudDescriptor().getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<String>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"615bf5b56d95ed8c9bf06a402db6c817d6bff21a","date":1509492118,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n    \n    assert TestInjection.injectFailUpdateRequests();\n    \n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n    \n    // check if client has requested minimum replication factor information\n    int minRf = -1; // disabled by default\n    if (replicationTracker != null) {\n      minRf = replicationTracker.minRf; // for subsequent requests in the same batch\n    } else {\n      SolrParams rp = cmd.getReq().getParams();      \n      String distribUpdate = rp.get(DISTRIB_UPDATE_PARAM);\n      // somewhat tricky logic here: we only activate the replication tracker if we're on \n      // a leader or this is the top-level request processor\n      if (distribUpdate == null || distribUpdate.equals(DistribPhase.TOLEADER.toString())) {\n        String minRepFact = rp.get(UpdateRequest.MIN_REPFACT);\n        if (minRepFact != null) {\n          try {\n            minRf = Integer.parseInt(minRepFact);\n          } catch (NumberFormatException nfe) {\n            minRf = -1;\n          }\n          \n          if (minRf <= 0)\n            throw new SolrException(ErrorCode.BAD_REQUEST, \"Invalid value \"+minRepFact+\" for \"+UpdateRequest.MIN_REPFACT+\n                \"; must be >0 and less than or equal to the collection replication factor.\");\n        }\n        \n        if (minRf > 1) {\n          String myShardId = forwardToLeader ? null : cloudDesc.getShardId();\n          replicationTracker = new RequestReplicationTracker(myShardId, minRf);\n        }                \n      }\n    }\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n    \n    boolean dropCmd = false;\n    if (!forwardToLeader) {      \n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n    \n    ModifiableSolrParams params = null;\n    if (nodes != null) {\n      params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n                 (isLeader || isSubShardLeader ?\n                  DistribPhase.FROMLEADER.toString() :\n                  DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n      \n      if (replicationTracker != null && minRf > 1)\n        params.set(UpdateRequest.MIN_REPFACT, String.valueOf(minRf));\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, replicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, replicationTracker);\n      }\n    }\n    \n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n    \n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65","date":1509551229,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, cloudDesc.getCollectionName());\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43f5f8344e80b4bfb2069917069430266753d2f0","date":1538584815,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Should be removed in Solr 9\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e","date":1551802585,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Should be removed in Solr 9\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Should be removed in Solr 9\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9d70e774cb25c8a8d2c3e5e84200f235f9168d87","date":1553016391,"type":3,"author":"Bar Rotstein","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#processAdd(AddUpdateCommand).mjava","sourceNew":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    setupRequest(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    doDistribAdd(cmd);\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","sourceOld":"  @Override\n  public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n    assert TestInjection.injectFailUpdateRequests();\n\n    if (isReadOnly()) {\n      throw new SolrException(ErrorCode.FORBIDDEN, \"Collection \" + collection + \" is read-only.\");\n    }\n\n    updateCommand = cmd;\n\n    if (zkEnabled) {\n      zkCheck();\n      nodes = setupRequest(cmd.getHashableId(), cmd.getSolrInputDocument());\n    } else {\n      isLeader = getNonZkLeaderAssumption(req);\n    }\n\n    // check if client has requested minimum replication factor information. will set replicationTracker to null if\n    // we aren't the leader or subShardLeader\n    checkReplicationTracker(cmd);\n\n    // If we were sent a previous version, set this to the AddUpdateCommand (if not already set)\n    if (!cmd.isInPlaceUpdate()) {\n      cmd.prevVersion = cmd.getReq().getParams().getLong(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, -1);\n    }\n    // TODO: if minRf > 1 and we know the leader is the only active replica, we could fail\n    // the request right here but for now I think it is better to just return the status\n    // to the client that the minRf wasn't reached and let them handle it    \n\n    boolean dropCmd = false;\n    if (!forwardToLeader) {\n      dropCmd = versionAdd(cmd);\n    }\n\n    if (dropCmd) {\n      // TODO: do we need to add anything to the response?\n      return;\n    }\n\n    if (zkEnabled && isLeader && !isSubShardLeader)  {\n      DocCollection coll = zkController.getClusterState().getCollection(collection);\n      List<Node> subShardLeaders = getSubShardLeaders(coll, cloudDesc.getShardId(), cmd.getHashableId(), cmd.getSolrInputDocument());\n      // the list<node> will actually have only one element for an add request\n      if (subShardLeaders != null && !subShardLeaders.isEmpty()) {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_PARENT, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, subShardLeaders, params, true);\n      }\n      final List<Node> nodesByRoutingRules = getNodesByRoutingRules(zkController.getClusterState(), coll, cmd.getHashableId(), cmd.getSolrInputDocument());\n      if (nodesByRoutingRules != null && !nodesByRoutingRules.isEmpty())  {\n        ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n        params.set(DISTRIB_UPDATE_PARAM, DistribPhase.FROMLEADER.toString());\n        params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n            zkController.getBaseUrl(), req.getCore().getName()));\n        params.set(DISTRIB_FROM_COLLECTION, collection);\n        params.set(DISTRIB_FROM_SHARD, cloudDesc.getShardId());\n        cmdDistrib.distribAdd(cmd, nodesByRoutingRules, params, true);\n      }\n    }\n\n    if (nodes != null) {\n      ModifiableSolrParams params = new ModifiableSolrParams(filterParams(req.getParams()));\n      params.set(DISTRIB_UPDATE_PARAM,\n          (isLeader || isSubShardLeader ?\n              DistribPhase.FROMLEADER.toString() :\n              DistribPhase.TOLEADER.toString()));\n      params.set(DISTRIB_FROM, ZkCoreNodeProps.getCoreUrl(\n          zkController.getBaseUrl(), req.getCore().getName()));\n\n      if (req.getParams().get(UpdateRequest.MIN_REPFACT) != null) {\n        // TODO: Kept for rolling upgrades only. Should be removed in Solr 9\n        params.set(UpdateRequest.MIN_REPFACT, req.getParams().get(UpdateRequest.MIN_REPFACT));\n      }\n\n      if (cmd.isInPlaceUpdate()) {\n        params.set(DISTRIB_INPLACE_PREVVERSION, String.valueOf(cmd.prevVersion));\n\n        // Use synchronous=true so that a new connection is used, instead\n        // of the update being streamed through an existing streaming client.\n        // When using a streaming client, the previous update\n        // and the current in-place update (that depends on the previous update), if reordered\n        // in the stream, can result in the current update being bottled up behind the previous\n        // update in the stream and can lead to degraded performance.\n        cmdDistrib.distribAdd(cmd, nodes, params, true, rollupReplicationTracker, leaderReplicationTracker);\n      } else {\n        cmdDistrib.distribAdd(cmd, nodes, params, false, rollupReplicationTracker, leaderReplicationTracker);\n      }\n    }\n\n    // TODO: what to do when no idField?\n    if (returnVersions && rsp != null && idField != null) {\n      if (addsResponse == null) {\n        addsResponse = new NamedList<>(1);\n        rsp.add(\"adds\",addsResponse);\n      }\n      if (scratch == null) scratch = new CharsRefBuilder();\n      idField.getType().indexedToReadable(cmd.getIndexedId(), scratch);\n      addsResponse.add(scratch.toString(), cmd.getVersion());\n    }\n\n    // TODO: keep track of errors?  needs to be done at a higher level though since\n    // an id may fail before it gets to this processor.\n    // Given that, it may also make sense to move the version reporting out of this\n    // processor too.\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["7350fba633b826986454e97668c5ad03b46bcaca"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["8f1ea787bab5bdb5e72685e55424898da05509b6","96adbab674ae121f8b6b3e10474070b4bd97a219"],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"77331c0e66a5501a256626c16dba384276ff05bf":["da888af1ab894358122a22229051215f58cf4d54"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["9d22d0f5940f155267b250876fa797ff69e8e6e7"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["6013b4c7388f1627659c8f96c44abd10a294d3a6"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"aba371508186796cc6151d8223a5b4e16d02e26e":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"bb734912d92a3243e7b18a32826749220d52d06c":["63c7ac6ed76316ffb50323bdf5c5bd973099b8c3"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"7350fba633b826986454e97668c5ad03b46bcaca":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["aba371508186796cc6151d8223a5b4e16d02e26e","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"da888af1ab894358122a22229051215f58cf4d54":["91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"4f9beac30228721abdefa5efd0601081e7c3421e":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["14d5815ecbef89580f5c48990bcd433f04f8563a"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["e2fe35ac47f8f51356d6c1724455d18f31c94fae","c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"c5a558d54519c651068ddb202f03befefb1514a7":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","a51acc2e27bfb18091f9395494aebe82266f7ce7"],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"14a570ea289e0d989057de081e0a4fb0255f4a53":["bb734912d92a3243e7b18a32826749220d52d06c"],"3333dd7044501b4f20231ea55ab64e688285d153":["77331c0e66a5501a256626c16dba384276ff05bf"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["407687e67faf6e1f02a211ca078d8e3eed631027","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4","415bbbe7da8065dd3c477bdc3c703c6425622998"],"43f5f8344e80b4bfb2069917069430266753d2f0":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["e7754464847b06ced605515bd48219280ede29e9"],"b7605579001505896d48b07160075a5c8b8e128e":["14d5815ecbef89580f5c48990bcd433f04f8563a","9d22d0f5940f155267b250876fa797ff69e8e6e7"],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2"],"e7754464847b06ced605515bd48219280ede29e9":["c5a558d54519c651068ddb202f03befefb1514a7"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["14a570ea289e0d989057de081e0a4fb0255f4a53"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0":["3333dd7044501b4f20231ea55ab64e688285d153"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"407687e67faf6e1f02a211ca078d8e3eed631027":["2806236d9dfa336ac413d3724a4123e7cf4d1e93","e7754464847b06ced605515bd48219280ede29e9"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["a6378064655e76cd7b908b1cab4ce425b384b508"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"63c7ac6ed76316ffb50323bdf5c5bd973099b8c3":["4f9beac30228721abdefa5efd0601081e7c3421e"],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["43f5f8344e80b4bfb2069917069430266753d2f0"],"a6378064655e76cd7b908b1cab4ce425b384b508":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"]},"commit2Childs":{"c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4":["415bbbe7da8065dd3c477bdc3c703c6425622998","598b5d23aa7c9732bf473c21a9cd309c44599394"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab":[],"ad55ff45b3a5483090d87a63019d0e6a8d4b5a65":["43f5f8344e80b4bfb2069917069430266753d2f0"],"77331c0e66a5501a256626c16dba384276ff05bf":["3333dd7044501b4f20231ea55ab64e688285d153"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["7350fba633b826986454e97668c5ad03b46bcaca"],"d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1":["a6378064655e76cd7b908b1cab4ce425b384b508"],"c5fa11bf621ab6d2af49b9e9e05dff485fec0de2":["aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","6013b4c7388f1627659c8f96c44abd10a294d3a6"],"aba371508186796cc6151d8223a5b4e16d02e26e":["05a14b2611ead08655a2b2bdc61632eb31316e57"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["37a0f60745e53927c4c876cfe5b5a58170f0646c","91e069c492cf4895697ef7b81df0ffb9a8bd4b48"],"bb734912d92a3243e7b18a32826749220d52d06c":["14a570ea289e0d989057de081e0a4fb0255f4a53"],"7350fba633b826986454e97668c5ad03b46bcaca":["c67fb7bad9a9f5e5f07a3166b8b8cfa0fe3f6ce4"],"14d5815ecbef89580f5c48990bcd433f04f8563a":["9d22d0f5940f155267b250876fa797ff69e8e6e7","b7605579001505896d48b07160075a5c8b8e128e"],"415bbbe7da8065dd3c477bdc3c703c6425622998":["4f9beac30228721abdefa5efd0601081e7c3421e","598b5d23aa7c9732bf473c21a9cd309c44599394"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"da888af1ab894358122a22229051215f58cf4d54":["77331c0e66a5501a256626c16dba384276ff05bf","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"4f9beac30228721abdefa5efd0601081e7c3421e":["63c7ac6ed76316ffb50323bdf5c5bd973099b8c3"],"9d22d0f5940f155267b250876fa797ff69e8e6e7":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","b7605579001505896d48b07160075a5c8b8e128e"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"c5a558d54519c651068ddb202f03befefb1514a7":["e7754464847b06ced605515bd48219280ede29e9"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"9d70e774cb25c8a8d2c3e5e84200f235f9168d87":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"14a570ea289e0d989057de081e0a4fb0255f4a53":["601f914e4448cab7640fecfb5d15f8f2e2af0bf6"],"3333dd7044501b4f20231ea55ab64e688285d153":["7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"43f5f8344e80b4bfb2069917069430266753d2f0":["fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e"],"8f1ea787bab5bdb5e72685e55424898da05509b6":["37a0f60745e53927c4c876cfe5b5a58170f0646c","96adbab674ae121f8b6b3e10474070b4bd97a219"],"91e069c492cf4895697ef7b81df0ffb9a8bd4b48":["da888af1ab894358122a22229051215f58cf4d54"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","0beaed456aa3358e5e4a99ea2aea994ef6c81de3"],"b7605579001505896d48b07160075a5c8b8e128e":[],"6013b4c7388f1627659c8f96c44abd10a294d3a6":["d8469c0c0b45f7e3da74918efc8ede2ad2efe2b1","05a14b2611ead08655a2b2bdc61632eb31316e57"],"e7754464847b06ced605515bd48219280ede29e9":["3d7c0c8a97beb56d2e168604f9928de17981eabe","407687e67faf6e1f02a211ca078d8e3eed631027"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"601f914e4448cab7640fecfb5d15f8f2e2af0bf6":["615bf5b56d95ed8c9bf06a402db6c817d6bff21a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"7a9d97c95155f9d108d71e447e2f3fdc15d0d1f0":["a51acc2e27bfb18091f9395494aebe82266f7ce7"],"d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","e2fe35ac47f8f51356d6c1724455d18f31c94fae"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"e19067e820b148e8dc0b240da4f2771cf7b68252":["2806236d9dfa336ac413d3724a4123e7cf4d1e93"],"0beaed456aa3358e5e4a99ea2aea994ef6c81de3":["8f1ea787bab5bdb5e72685e55424898da05509b6"],"63c7ac6ed76316ffb50323bdf5c5bd973099b8c3":["bb734912d92a3243e7b18a32826749220d52d06c"],"2806236d9dfa336ac413d3724a4123e7cf4d1e93":["c5a558d54519c651068ddb202f03befefb1514a7","407687e67faf6e1f02a211ca078d8e3eed631027"],"fc48b0cd4ac45fae4c9660d1828b3fbafffdd12e":["9d70e774cb25c8a8d2c3e5e84200f235f9168d87"],"a6378064655e76cd7b908b1cab4ce425b384b508":["e19067e820b148e8dc0b240da4f2771cf7b68252"],"a51acc2e27bfb18091f9395494aebe82266f7ce7":["14d5815ecbef89580f5c48990bcd433f04f8563a","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","d9652a1b09ee0e7d6533fdfedf1d7c4d9036b49d"],"615bf5b56d95ed8c9bf06a402db6c817d6bff21a":["ad55ff45b3a5483090d87a63019d0e6a8d4b5a65"],"e2fe35ac47f8f51356d6c1724455d18f31c94fae":["c5fa11bf621ab6d2af49b9e9e05dff485fec0de2","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","9946ea6d8ddf0b8c20b2ca6a816b7168b023a6ab","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","05a14b2611ead08655a2b2bdc61632eb31316e57","fe33227f6805edab2036cbb80645cc4e2d1fa424","74f45af4339b0daf7a95c820ab88c1aea74fbce0","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","598b5d23aa7c9732bf473c21a9cd309c44599394","b7605579001505896d48b07160075a5c8b8e128e","0d22ac6a4146774c1bc8400160fc0b6150294e92","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}