{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","commits":[{"id":"4c18a95e9168a30be855f5d5e7d61a863186fdc5","date":1415142581,"type":1,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n      String field, String subField, Deque<String> fnames,Deque<String> vnames,DocSet docs) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", kv.getValue() );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset) );\n          }\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"658218bdad5bc0415007e8e0cd9197fb3b0298af","date":1423726262,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under teh specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-useable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c169312e8f621502de0661c48a43e492983cd28a","date":1423728604,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<Integer>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d12bbc45d641864ffe03291bc30f178eb34e434c","date":1426001646,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          // for pivots, we *always* include requested stats - even if 'empty'\n          pivot.add(\"stats\", StatsComponent.convertToResponse(true, stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aa62c79a7afa4d7f22e1f71b883659f3213d7db1","date":1435334422,"type":5,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],ParsedParams,List[StatsField]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#doPivots(NamedList[Integer],String,String,Deque[String],Deque[String],DocSet,List[StatsField]).mjava","sourceNew":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             ParsedParams parsed, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        final DocSet subset = getSubset(parsed.docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, parsed.withDocs(subset));\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, parsed.withDocs(subset), statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","sourceOld":"  /**\n   * Recursive function to compute all the pivot counts for the values under the specified field\n   */\n  protected List<NamedList<Object>> doPivots(NamedList<Integer> superFacets,\n                                             String field, String subField, \n                                             Deque<String> fnames, Deque<String> vnames, \n                                             DocSet docs, List<StatsField> statsFields) \n    throws IOException {\n\n    boolean isShard = rb.req.getParams().getBool(ShardParams.IS_SHARD, false);\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    // TODO: optimize to avoid converting to an external string and then having to convert back to internal below\n    SchemaField sfield = searcher.getSchema().getField(field);\n    FieldType ftype = sfield.getType();\n\n    String nextField = fnames.poll();\n\n    // re-usable BytesRefBuilder for conversion of term values to Objects\n    BytesRefBuilder termval = new BytesRefBuilder(); \n\n    List<NamedList<Object>> values = new ArrayList<>( superFacets.size() );\n    for (Map.Entry<String, Integer> kv : superFacets) {\n      // Only sub-facet if parent facet has positive count - still may not be any values for the sub-field though\n      if (kv.getValue() >= getMinCountForField(field)) {  \n        final String fieldValue = kv.getKey();\n        final int pivotCount = kv.getValue();\n\n        SimpleOrderedMap<Object> pivot = new SimpleOrderedMap<>();\n        pivot.add( \"field\", field );\n        if (null == fieldValue) {\n          pivot.add( \"value\", null );\n        } else {\n          ftype.readableToIndexed(fieldValue, termval);\n          pivot.add( \"value\", ftype.toObject(sfield, termval.get()) );\n        }\n        pivot.add( \"count\", pivotCount );\n\n        DocSet subset = getSubset(docs, sfield, fieldValue);\n        \n        if( subField != null )  {\n          NamedList<Integer> facetCounts;\n          if(!vnames.isEmpty()){\n            String val = vnames.pop();\n            facetCounts = new NamedList<>();\n            facetCounts.add(val, getSubsetSize(subset,\n                                               searcher.getSchema().getField(subField),\n                                               val));\n          } else {\n            facetCounts = this.getTermCountsForPivots(subField, subset);\n          }\n\n          if (facetCounts.size() >= 1) {\n            pivot.add( \"pivot\", doPivots( facetCounts, subField, nextField, fnames, vnames, subset, statsFields ) );\n          }\n        }\n        if ((isShard || 0 < pivotCount) && ! statsFields.isEmpty()) {\n          Map<String, StatsValues> stv = new LinkedHashMap<>();\n          for (StatsField statsField : statsFields) {\n            stv.put(statsField.getOutputKey(), statsField.computeLocalStatsValues(subset));\n          }\n          pivot.add(\"stats\", StatsComponent.convertToResponse(stv));\n        }\n        values.add( pivot );\n      }\n\n    }\n    // put the field back on the list\n    fnames.push( nextField );\n    return values;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["c169312e8f621502de0661c48a43e492983cd28a","d12bbc45d641864ffe03291bc30f178eb34e434c"],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d12bbc45d641864ffe03291bc30f178eb34e434c":["c169312e8f621502de0661c48a43e492983cd28a"],"c169312e8f621502de0661c48a43e492983cd28a":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["d12bbc45d641864ffe03291bc30f178eb34e434c"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["aa62c79a7afa4d7f22e1f71b883659f3213d7db1"]},"commit2Childs":{"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"4c18a95e9168a30be855f5d5e7d61a863186fdc5":["658218bdad5bc0415007e8e0cd9197fb3b0298af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4c18a95e9168a30be855f5d5e7d61a863186fdc5"],"c169312e8f621502de0661c48a43e492983cd28a":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","d12bbc45d641864ffe03291bc30f178eb34e434c"],"d12bbc45d641864ffe03291bc30f178eb34e434c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","aa62c79a7afa4d7f22e1f71b883659f3213d7db1"],"658218bdad5bc0415007e8e0cd9197fb3b0298af":["c169312e8f621502de0661c48a43e492983cd28a"],"aa62c79a7afa4d7f22e1f71b883659f3213d7db1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}