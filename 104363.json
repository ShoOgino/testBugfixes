{"path":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.CollectionOperation#convertPrefixToMap(SolrParams,Map[String,Object],String).mjava","commits":[{"id":"b10ab715806383f3d7f9eece13c26772a9116022","date":1517176579,"type":0,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.CollectionOperation#convertPrefixToMap(SolrParams,Map[String,Object],String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Places all prefixed properties in the sink map (or a new map) using the prefix as the key and a map of\n     * all prefixed properties as the value. The sub-map keys have the prefix removed.\n     *\n     * @param params The solr params from which to extract prefixed properties.\n     * @param sink The map to add the properties too.\n     * @param prefix The prefix to identify properties to be extracted\n     * @return The sink map, or a new map if the sink map was null\n     */\n    private static Map<String, Object> convertPrefixToMap(SolrParams params, Map<String, Object> sink, String prefix) {\n      Map<String,Object> result = new LinkedHashMap<>();\n      Iterator<String> iter =  params.getParameterNamesIterator();\n      while (iter.hasNext()) {\n        String param = iter.next();\n        if (param.startsWith(prefix)) {\n          result.put(param.substring(prefix.length()+1), params.get(param));\n        }\n      }\n      if (sink == null) {\n        sink = new LinkedHashMap<>();\n      }\n      sink.put(prefix, result);\n      return sink;\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.CollectionOperation#convertPrefixToMap(SolrParams,Map[String,Object],String).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/CollectionsHandler.CollectionOperation#convertPrefixToMap(SolrParams,Map[String,Object],String).mjava","sourceNew":"    /**\n     * Places all prefixed properties in the sink map (or a new map) using the prefix as the key and a map of\n     * all prefixed properties as the value. The sub-map keys have the prefix removed.\n     *\n     * @param params The solr params from which to extract prefixed properties.\n     * @param sink   The map to add the properties too.\n     * @param prefix The prefix to identify properties to be extracted\n     * @return The sink map, or a new map if the sink map was null\n     */\n    private static Map<String, Object> convertPrefixToMap(SolrParams params, Map<String, Object> sink, String prefix) {\n      Map<String, Object> result = new LinkedHashMap<>();\n      Iterator<String> iter = params.getParameterNamesIterator();\n      while (iter.hasNext()) {\n        String param = iter.next();\n        if (param.startsWith(prefix)) {\n          result.put(param.substring(prefix.length() + 1), params.get(param));\n        }\n      }\n      if (sink == null) {\n        sink = new LinkedHashMap<>();\n      }\n      sink.put(prefix, result);\n      return sink;\n    }\n\n","sourceOld":"    /**\n     * Places all prefixed properties in the sink map (or a new map) using the prefix as the key and a map of\n     * all prefixed properties as the value. The sub-map keys have the prefix removed.\n     *\n     * @param params The solr params from which to extract prefixed properties.\n     * @param sink The map to add the properties too.\n     * @param prefix The prefix to identify properties to be extracted\n     * @return The sink map, or a new map if the sink map was null\n     */\n    private static Map<String, Object> convertPrefixToMap(SolrParams params, Map<String, Object> sink, String prefix) {\n      Map<String,Object> result = new LinkedHashMap<>();\n      Iterator<String> iter =  params.getParameterNamesIterator();\n      while (iter.hasNext()) {\n        String param = iter.next();\n        if (param.startsWith(prefix)) {\n          result.put(param.substring(prefix.length()+1), params.get(param));\n        }\n      }\n      if (sink == null) {\n        sink = new LinkedHashMap<>();\n      }\n      sink.put(prefix, result);\n      return sink;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"2668c99990e4c94a78bac005aa682b7c5986d23a":["b10ab715806383f3d7f9eece13c26772a9116022"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b10ab715806383f3d7f9eece13c26772a9116022":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2668c99990e4c94a78bac005aa682b7c5986d23a"]},"commit2Childs":{"2668c99990e4c94a78bac005aa682b7c5986d23a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b10ab715806383f3d7f9eece13c26772a9116022"],"b10ab715806383f3d7f9eece13c26772a9116022":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}