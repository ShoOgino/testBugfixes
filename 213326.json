{"path":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","commits":[{"id":"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223","date":1227051709,"type":0,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Consumers (e. g. the indexer) use this method to advance the stream \n\t * to the next token. Implementing classes must implement this method \n\t * and update the appropriate {@link Attribute}s with content of the \n\t * next token.\n\t * <p>\n\t * This method is called for every token of a document, so an efficient\n\t * implementation is crucial for good performance. To avoid calls to \n\t * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n\t * downcasts, references to all {@link Attribute}s that this stream uses \n\t * should be retrieved during instantiation.   \n\t * <p>\n\t * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n\t * \n\t * @return false for end of stream; true otherwise\n\t *\n\t * <p>\n\t * <b>Note that this method will be defined abstract in Lucene 3.0.<b>\n\t */\n\tpublic boolean incrementToken() throws IOException {\n\t  // subclasses must implement this method; will be made abstract in Lucene 3.0\n\t  return false;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6277e73848e2c1ff55a4f0bcd99f8bfc68c46be","date":1245097022,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"\t/**\n\t * Consumers (e. g. the indexer) use this method to advance the stream \n\t * to the next token. Implementing classes must implement this method \n\t * and update the appropriate {@link Attribute}s with content of the \n\t * next token.\n\t * <p>\n\t * This method is called for every token of a document, so an efficient\n\t * implementation is crucial for good performance. To avoid calls to \n\t * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n\t * downcasts, references to all {@link Attribute}s that this stream uses \n\t * should be retrieved during instantiation.   \n\t * <p>\n\t * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n\t * \n\t * @return false for end of stream; true otherwise\n\t *\n\t * <p>\n\t * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n\t */\n\tpublic boolean incrementToken() throws IOException {\n\t  // subclasses must implement this method; will be made abstract in Lucene 3.0\n\t  return false;\n\t}\n\n","sourceOld":"\t/**\n\t * Consumers (e. g. the indexer) use this method to advance the stream \n\t * to the next token. Implementing classes must implement this method \n\t * and update the appropriate {@link Attribute}s with content of the \n\t * next token.\n\t * <p>\n\t * This method is called for every token of a document, so an efficient\n\t * implementation is crucial for good performance. To avoid calls to \n\t * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n\t * downcasts, references to all {@link Attribute}s that this stream uses \n\t * should be retrieved during instantiation.   \n\t * <p>\n\t * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n\t * \n\t * @return false for end of stream; true otherwise\n\t *\n\t * <p>\n\t * <b>Note that this method will be defined abstract in Lucene 3.0.<b>\n\t */\n\tpublic boolean incrementToken() throws IOException {\n\t  // subclasses must implement this method; will be made abstract in Lucene 3.0\n\t  return false;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec8b5a20a12931b8d7e616c79c5248ae06cc5568","date":1248471948,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (e. g. the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"\t/**\n\t * Consumers (e. g. the indexer) use this method to advance the stream \n\t * to the next token. Implementing classes must implement this method \n\t * and update the appropriate {@link Attribute}s with content of the \n\t * next token.\n\t * <p>\n\t * This method is called for every token of a document, so an efficient\n\t * implementation is crucial for good performance. To avoid calls to \n\t * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n\t * downcasts, references to all {@link Attribute}s that this stream uses \n\t * should be retrieved during instantiation.   \n\t * <p>\n\t * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n\t * \n\t * @return false for end of stream; true otherwise\n\t *\n\t * <p>\n\t * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n\t */\n\tpublic boolean incrementToken() throws IOException {\n\t  // subclasses must implement this method; will be made abstract in Lucene 3.0\n\t  return false;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31","date":1249940086,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (e. g. the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Consumers (e. g. the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4993710af1ffe1511739260d41658f3cfba23e5","date":1250782932,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (eg the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Consumers (e. g. the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39c72a0a1f317a4165b759c7842b5d73d7858d1d","date":1251209760,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Consumers (eg the indexer) use this method to advance the stream \n   * to the next token. Implementing classes must implement this method \n   * and update the appropriate {@link AttributeImpl}s with content of the \n   * next token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to \n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} and\n   * downcasts, references to all {@link AttributeImpl}s that this stream uses \n   * should be retrieved during instantiation.   \n   * <p>\n   * To make sure that filters and consumers know which attributes are available\n   * the attributes must be added during instantiation. Filters and \n   * consumers are not required to check for availability of attributes in {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   *\n   * <p>\n   * <b>Note that this method will be defined abstract in Lucene 3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4821e344090113a4e6d4d31265a0166ab07930d","date":1251215880,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert !onlyUseNewAPI && tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ff23e1fee4e47c164bbc07cb60f092b919ea05a","date":1253894338,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","sourceOld":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"439b0fe2f799d1c722151e88e32bdefad8d34ebe","date":1255282509,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)},\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   */\n  public abstract boolean incrementToken() throws IOException;\n\n","sourceOld":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)} or downcasts,\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   * \n   *         <p>\n   *         <b>Note that this method will be defined abstract in Lucene\n   *         3.0.</b>\n   */\n  public boolean incrementToken() throws IOException {\n    assert tokenWrapper != null;\n    \n    final Token token;\n    if (supportedMethods.hasReusableNext) {\n      token = next(tokenWrapper.delegate);\n    } else {\n      assert supportedMethods.hasNext;\n      token = next();\n    }\n    if (token == null) return false;\n    tokenWrapper.delegate = token;\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4983c58e0e4597fc599fc70ef2feafd4ad61fbf1","date":1256476130,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":"  /**\n   * Consumers (i.e., {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)},\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   */\n  public abstract boolean incrementToken() throws IOException;\n\n","sourceOld":"  /**\n   * Consumers (ie {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)},\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   */\n  public abstract boolean incrementToken() throws IOException;\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":4,"author":"Dawid Weiss","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/analysis/TokenStream#incrementToken().mjava","sourceNew":null,"sourceOld":"  /**\n   * Consumers (i.e., {@link IndexWriter}) use this method to advance the stream to\n   * the next token. Implementing classes must implement this method and update\n   * the appropriate {@link AttributeImpl}s with the attributes of the next\n   * token.\n   * <P>\n   * The producer must make no assumptions about the attributes after the method\n   * has been returned: the caller may arbitrarily change it. If the producer\n   * needs to preserve the state for subsequent calls, it can use\n   * {@link #captureState} to create a copy of the current attribute state.\n   * <p>\n   * This method is called for every token of a document, so an efficient\n   * implementation is crucial for good performance. To avoid calls to\n   * {@link #addAttribute(Class)} and {@link #getAttribute(Class)},\n   * references to all {@link AttributeImpl}s that this stream uses should be\n   * retrieved during instantiation.\n   * <p>\n   * To ensure that filters and consumers know which attributes are available,\n   * the attributes must be added during instantiation. Filters and consumers\n   * are not required to check for availability of attributes in\n   * {@link #incrementToken()}.\n   * \n   * @return false for end of stream; true otherwise\n   */\n  public abstract boolean incrementToken() throws IOException;\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4983c58e0e4597fc599fc70ef2feafd4ad61fbf1":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["8ff23e1fee4e47c164bbc07cb60f092b919ea05a"],"f4993710af1ffe1511739260d41658f3cfba23e5":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["f4993710af1ffe1511739260d41658f3cfba23e5"],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"f6277e73848e2c1ff55a4f0bcd99f8bfc68c46be":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4821e344090113a4e6d4d31265a0166ab07930d":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["4983c58e0e4597fc599fc70ef2feafd4ad61fbf1"],"8ff23e1fee4e47c164bbc07cb60f092b919ea05a":["f4821e344090113a4e6d4d31265a0166ab07930d"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["f6277e73848e2c1ff55a4f0bcd99f8bfc68c46be"]},"commit2Childs":{"74a5e7f20b4a444da9df3b2c0f331fa7a1f64223":["f6277e73848e2c1ff55a4f0bcd99f8bfc68c46be"],"4983c58e0e4597fc599fc70ef2feafd4ad61fbf1":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"439b0fe2f799d1c722151e88e32bdefad8d34ebe":["4983c58e0e4597fc599fc70ef2feafd4ad61fbf1"],"f4993710af1ffe1511739260d41658f3cfba23e5":["39c72a0a1f317a4165b759c7842b5d73d7858d1d"],"0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31":["f4993710af1ffe1511739260d41658f3cfba23e5"],"39c72a0a1f317a4165b759c7842b5d73d7858d1d":["f4821e344090113a4e6d4d31265a0166ab07930d"],"f6277e73848e2c1ff55a4f0bcd99f8bfc68c46be":["ec8b5a20a12931b8d7e616c79c5248ae06cc5568"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74a5e7f20b4a444da9df3b2c0f331fa7a1f64223"],"f4821e344090113a4e6d4d31265a0166ab07930d":["8ff23e1fee4e47c164bbc07cb60f092b919ea05a"],"8ff23e1fee4e47c164bbc07cb60f092b919ea05a":["439b0fe2f799d1c722151e88e32bdefad8d34ebe"],"ec8b5a20a12931b8d7e616c79c5248ae06cc5568":["0833fee1ce16a2b8e10f21cbccd2e93f3d8ccf31"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}