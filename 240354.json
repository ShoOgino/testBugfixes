{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","commits":[{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/DeleteCollectionCmd#call(ClusterState,CloudConfig,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results) throws Exception {\n    Object o = message.get(MaintainRoutedAliasCmd.INVOKED_BY_ROUTED_ALIAS);\n    if (o != null) {\n      ((Runnable)o).run(); // this will ensure the collection is removed from the alias before it disappears.\n    }\n    final String extCollection = message.getStr(NAME);\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n\n    if (zkStateReader.aliasesManager != null) { // not a mock ZkStateReader\n      zkStateReader.aliasesManager.update(); // aliases may have been stale; get latest from ZK\n    }\n\n    boolean followAliases = message.getBool(FOLLOW_ALIASES, false);\n    List<String> aliasReferences = checkAliasReference(zkStateReader, extCollection, followAliases);\n\n    Aliases aliases = zkStateReader.getAliases();\n\n    String collection;\n    if (followAliases) {\n      collection = aliases.resolveSimpleAlias(extCollection);\n    } else {\n      collection = extCollection;\n    }\n\n    checkNotColocatedWith(zkStateReader, collection);\n\n    final boolean deleteHistory = message.getBool(CoreAdminParams.DELETE_METRICS_HISTORY, true);\n\n    boolean removeCounterNode = true;\n    try {\n      // Remove the snapshots meta-data for this collection in ZK. Deleting actual index files\n      // should be taken care of as part of collection delete operation.\n      SolrZkClient zkClient = zkStateReader.getZkClient();\n      SolrSnapshotManager.cleanupCollectionLevelSnapshots(zkClient, collection);\n\n      if (zkStateReader.getClusterState().getCollectionOrNull(collection) == null) {\n        if (zkStateReader.getZkClient().exists(ZkStateReader.COLLECTIONS_ZKNODE + \"/\" + collection, true)) {\n          // if the collection is not in the clusterstate, but is listed in zk, do nothing, it will just\n          // be removed in the finally - we cannot continue, because the below code will error if the collection\n          // is not in the clusterstate\n          return;\n        }\n      }\n      // remove collection-level metrics history\n      if (deleteHistory) {\n        MetricsHistoryHandler historyHandler = ocmh.overseer.getCoreContainer().getMetricsHistoryHandler();\n        if (historyHandler != null) {\n          String registry = SolrMetricManager.getRegistryName(SolrInfoBean.Group.collection, collection);\n          historyHandler.removeHistory(registry);\n        }\n      }\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.UNLOAD.toString());\n      params.set(CoreAdminParams.DELETE_INSTANCE_DIR, true);\n      params.set(CoreAdminParams.DELETE_DATA_DIR, true);\n      params.set(CoreAdminParams.DELETE_METRICS_HISTORY, deleteHistory);\n\n      String asyncId = message.getStr(ASYNC);\n\n      Set<String> okayExceptions = new HashSet<>(1);\n      okayExceptions.add(NonExistentCoreException.class.getName());\n      ZkNodeProps internalMsg = message.plus(NAME, collection);\n\n      @SuppressWarnings({\"unchecked\"})\n      List<Replica> failedReplicas = ocmh.collectionCmd(internalMsg, params, results, null, asyncId, okayExceptions);\n      for (Replica failedReplica : failedReplicas) {\n        boolean isSharedFS = failedReplica.getBool(ZkStateReader.SHARED_STORAGE_PROP, false) && failedReplica.get(\"dataDir\") != null;\n        if (isSharedFS) {\n          // if the replica use a shared FS and it did not receive the unload message, then counter node should not be removed\n          // because when a new collection with same name is created, new replicas may reuse the old dataDir\n          removeCounterNode = false;\n          break;\n        }\n      }\n\n      ZkNodeProps m = new ZkNodeProps(Overseer.QUEUE_OPERATION, DELETE.toLower(), NAME, collection);\n      ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n      // wait for a while until we don't see the collection\n      zkStateReader.waitForState(collection, 60, TimeUnit.SECONDS, (collectionState) -> collectionState == null);\n\n      // we can delete any remaining unique aliases\n      if (!aliasReferences.isEmpty()) {\n        ocmh.zkStateReader.aliasesManager.applyModificationAndExportToZk(a -> {\n          for (String alias : aliasReferences) {\n            a = a.cloneWithCollectionAlias(alias, null);\n          }\n          return a;\n        });\n      }\n\n      // delete related config set iff: it is auto generated AND not related to any other collection\n      String configSetName = zkStateReader.readConfigName(collection);\n\n      if (ConfigSetsHandlerApi.isAutoGeneratedConfigSet(configSetName)) {\n        boolean configSetIsUsedByOtherCollection = false;\n\n        // make sure the configSet is not shared with other collections\n        // Similar to what happens in: OverseerConfigSetMessageHandler::deleteConfigSet\n        for (Map.Entry<String, DocCollection> entry : zkStateReader.getClusterState().getCollectionsMap().entrySet()) {\n          String otherConfigSetName = null;\n          try {\n            otherConfigSetName = zkStateReader.readConfigName(entry.getKey());\n          } catch (KeeperException ex) {\n            // ignore 'no config found' errors\n          }\n          if (configSetName.equals(otherConfigSetName)) {\n            configSetIsUsedByOtherCollection = true;\n            break;\n          }\n        }\n\n        if (!configSetIsUsedByOtherCollection) {\n          // delete the config set\n          zkStateReader.getConfigManager().deleteConfigDir(configSetName);\n        }\n      }\n\n//      TimeOut timeout = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n//      boolean removed = false;\n//      while (! timeout.hasTimedOut()) {\n//        timeout.sleep(100);\n//        removed = !zkStateReader.getClusterState().hasCollection(collection);\n//        if (removed) {\n//          timeout.sleep(500); // just a bit of time so it's more likely other\n//          // readers see on return\n//          break;\n//        }\n//      }\n//      if (!removed) {\n//        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n//            \"Could not fully remove collection: \" + collection);\n//      }\n    } finally {\n\n      try {\n        String collectionPath =  ZkStateReader.getCollectionPathRoot(collection);\n        if (zkStateReader.getZkClient().exists(collectionPath, true)) {\n          if (removeCounterNode) {\n            zkStateReader.getZkClient().clean(collectionPath);\n          } else {\n            final String counterNodePath = Assign.getCounterNodePath(collection);\n            zkStateReader.getZkClient().clean(collectionPath, s -> !s.equals(counterNodePath));\n          }\n        }\n      } catch (InterruptedException e) {\n        SolrException.log(log, \"Cleaning up collection in zk was interrupted:\"\n            + collection, e);\n        Thread.currentThread().interrupt();\n      } catch (KeeperException e) {\n        SolrException.log(log, \"Problem cleaning up collection in zk:\"\n            + collection, e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}