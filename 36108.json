{"path":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","commits":[{"id":"13ea66b549e25413e4e3057bf3492ab828899110","date":1454958424,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1b0febf62c2d9baeee7db38998d9197700ccbab9","date":1454958476,"type":1,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    Collection<String> newNRTFiles = job.getFileNames();\n    long newPrimaryGen = job.getCopyState().primaryGen;\n    maybeNewPrimary(newPrimaryGen);\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b844e2ae5435a8d4d925003c10027c25e26e02d","date":1455044345,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(System.out);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68496c2200e559fb7802f7575427b7a482659afb","date":1455207618,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"/dev/null","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ccf8df9c963832056c9f6fc1a4a7bb4f79375c44","date":1493290764,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + curVersion + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","pathOld":"lucene/replicator/src/java/org/apache/lucene/replicator/nrt/ReplicaNode#newNRTPoint(long,long).mjava","sourceNew":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + curVersion + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","sourceOld":"  /** Call this to notify this replica node that a new NRT infos is available on the primary.\n   *  We kick off a job (runs in the background) to copy files across, and open a new reader once that's done. */\n  public synchronized CopyJob newNRTPoint(long newPrimaryGen, long version) throws IOException {\n\n    if (isClosed()) {\n      throw new AlreadyClosedException(\"this replica is closed: state=\" + state);\n    }\n\n    // Cutover (possibly) to new primary first, so we discard any pre-copied merged segments up front, before checking for which files need\n    // copying.  While it's possible the pre-copied merged segments could still be useful to us, in the case that the new primary is either\n    // the same primary (just e.g. rebooted), or a promoted replica that had a newer NRT point than we did that included the pre-copied\n    // merged segments, it's still a bit risky to rely solely on checksum/file length to catch the difference, so we defensively discard\n    // here and re-copy in that case:\n    maybeNewPrimary(newPrimaryGen);\n\n    // Caller should not \"publish\" us until we have finished .start():\n    assert mgr != null;\n\n    if (\"idle\".equals(state)) {\n      state = \"syncing\";\n    }\n\n    long curVersion = getCurrentSearchingVersion();\n\n    message(\"top: start sync sis.version=\" + version);\n\n    if (version == curVersion) {\n      // Caller releases the CopyState:\n      message(\"top: new NRT point has same version as current; skipping\");\n      return null;\n    }\n\n    if (version < curVersion) {\n      // This can happen, if two syncs happen close together, and due to thread scheduling, the incoming older version runs after the newer version\n      message(\"top: new NRT point (version=\" + version + \") is older than current (version=\" + version + \"); skipping\");\n      return null;\n    }\n\n    final long startNS = System.nanoTime();\n\n    message(\"top: newNRTPoint\");\n    CopyJob job = null;\n    try {\n      job = newCopyJob(\"NRT point sync version=\" + version,\n                       null,\n                       lastFileMetaData,\n                       true,\n                       new CopyJob.OnceDone() {\n                         @Override\n                         public void run(CopyJob job) {\n                           try {\n                             finishNRTCopy(job, startNS);\n                           } catch (IOException ioe) {\n                             throw new RuntimeException(ioe);\n                           }\n                         }\n                       });\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring communication exception creating CopyJob: \" + nce);\n      //nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    assert newPrimaryGen == job.getCopyState().primaryGen;\n\n    Collection<String> newNRTFiles = job.getFileNames();\n\n    message(\"top: newNRTPoint: job files=\" + newNRTFiles);\n\n    if (curNRTCopy != null) {\n      job.transferAndCancel(curNRTCopy);\n      assert curNRTCopy.getFailed();\n    }\n\n    curNRTCopy = job;\n\n    for(String fileName : curNRTCopy.getFileNamesToCopy()) {\n      assert lastCommitFiles.contains(fileName) == false: \"fileName=\" + fileName + \" is in lastCommitFiles and is being copied?\";\n      synchronized (mergeCopyJobs) {\n        for (CopyJob mergeJob : mergeCopyJobs) {\n          if (mergeJob.getFileNames().contains(fileName)) {\n            // TODO: we could maybe transferAndCancel here?  except CopyJob can't transferAndCancel more than one currently\n            message(\"top: now cancel merge copy job=\" + mergeJob + \": file \" + fileName + \" is now being copied via NRT point\");\n            mergeJob.cancel(\"newNRTPoint is copying over the same file\", null);\n          }\n        }\n      }\n    }\n\n    try {\n      job.start();\n    } catch (NodeCommunicationException nce) {\n      // E.g. primary could crash/close when we are asking it for the copy state:\n      message(\"top: ignoring exception starting CopyJob: \" + nce);\n      nce.printStackTrace(printStream);\n      if (state.equals(\"syncing\")) {\n        state = \"idle\";\n      }\n      return null;\n    }\n\n    // Runs in the background jobs thread, maybe slowly/throttled, and calls finishSync once it's done:\n    launch(curNRTCopy);\n    return curNRTCopy;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["68496c2200e559fb7802f7575427b7a482659afb","ccf8df9c963832056c9f6fc1a4a7bb4f79375c44"],"1b0febf62c2d9baeee7db38998d9197700ccbab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","13ea66b549e25413e4e3057bf3492ab828899110"],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["13ea66b549e25413e4e3057bf3492ab828899110"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ccf8df9c963832056c9f6fc1a4a7bb4f79375c44":["68496c2200e559fb7802f7575427b7a482659afb"],"68496c2200e559fb7802f7575427b7a482659afb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"13ea66b549e25413e4e3057bf3492ab828899110":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ccf8df9c963832056c9f6fc1a4a7bb4f79375c44"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"1b0febf62c2d9baeee7db38998d9197700ccbab9":[],"2b844e2ae5435a8d4d925003c10027c25e26e02d":["68496c2200e559fb7802f7575427b7a482659afb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1b0febf62c2d9baeee7db38998d9197700ccbab9","68496c2200e559fb7802f7575427b7a482659afb","13ea66b549e25413e4e3057bf3492ab828899110"],"ccf8df9c963832056c9f6fc1a4a7bb4f79375c44":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"68496c2200e559fb7802f7575427b7a482659afb":["e9017cf144952056066919f1ebc7897ff9bd71b1","ccf8df9c963832056c9f6fc1a4a7bb4f79375c44"],"13ea66b549e25413e4e3057bf3492ab828899110":["1b0febf62c2d9baeee7db38998d9197700ccbab9","2b844e2ae5435a8d4d925003c10027c25e26e02d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","1b0febf62c2d9baeee7db38998d9197700ccbab9","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}